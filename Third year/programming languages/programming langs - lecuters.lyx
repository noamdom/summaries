#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{culmus}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language hebrew
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "cmr" "default"
\font_sans "cmss" "default"
\font_typewriter "cmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing onehalf
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 2cm
\headsep 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
שפות תכנות
\end_layout

\begin_layout Standard
\align center
על פי הרצאותי של ד
\begin_inset Quotes erd
\end_inset

ר עמרי ערן
\end_layout

\begin_layout Standard
\align center
להארות/תיקונים - נעם דומוביץ
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
, פאל:
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
0508752542
\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\align left

\series bold
הרצאה 1 
\end_layout

\begin_layout Itemize
מרצה: ד
\begin_inset Quotes erd
\end_inset

ר עמרי ערן
\end_layout

\begin_layout Itemize
בחינה : 
\begin_inset Formula $80\%$
\end_inset

 מטלות 
\begin_inset Formula $20\%$
\end_inset

 , צריך לעבור בשניהם.
\end_layout

\begin_layout Itemize
מטלות חלקן ביחידים וחלקן בזוגות
\end_layout

\begin_layout Standard
לינקים שימושיים:
\end_layout

\begin_layout Itemize
האתר של ברזילי: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://pl.barzilay.org/resources.html
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
אוסף פונקציות: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://docs.racket-lang.org/racket-cheat/index.html
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
הקדמה מהן יסודות של השפה? 
\end_layout

\begin_layout Itemize
תחביר 
\begin_inset Formula $(Syntax)$
\end_inset

 - מערכת הכללים של השפה.
 
\end_layout

\begin_layout Itemize
סמנטיקה 
\begin_inset Formula $\left(Semantics\right)$
\end_inset

 משמעויות.
 כגון: משמעות העומדת מאחורי מילה מסוימת בשפה.
 
\end_layout

\begin_layout Subsubsection
הבדל בין תחביר לסמנטיקה
\end_layout

\begin_layout Itemize
תחביר חשוב בעיקר לצורכי "קוסמטיקה".
 הוא נועד לשרת את הסמנטיקה.
 
\bar under
סמנטיקה חשובה יותר מהתחביר
\bar default
.
 שכן, תחביר אפשר לשנות.
 
\end_layout

\begin_layout Itemize
לדוג':
\end_layout

\begin_deeper
\begin_layout Itemize
אם נסתכל על מס' 42 שכתוב בקובץ כלשהו- מדובר בעצם בייצוג של שני ערכי ASCII
 ,לעומת המס' 42 שמאוחסן בזיכרון.
 
\end_layout

\begin_layout Itemize
המילה "שוד" - היא סתם מילה.
 אבל אם נחשוב על המשמעות שלה - אפשר לשבת בכלא בגלל ביצוע שוד.
\end_layout

\begin_layout Itemize
דוגמה נוספת המילה 'חמור' - נוכל להחליט שמהיום היא 'למור' והיא מתייחסת לאותה
 חיה ולאחר זמן 
\begin_inset Quotes eld
\end_inset

הסתגלות
\begin_inset Quotes erd
\end_inset

, כולנו נתרגל למילה החדשה
\end_layout

\begin_layout Itemize
דוגמה מעולם שפות התכנות - ניקח אוסף הצהרות זהות משפות שונות:
\end_layout

\begin_layout Itemize

\lang english
a[25]+5 (Java:)
\end_layout

\begin_layout Itemize

\lang english
(+ (vector-ref a 25) 5) (Racket:)
\end_layout

\begin_layout Itemize

\lang english
a[25]+5 (JavaScript:) 
\end_layout

\begin_layout Itemize

\lang english
a[25]+5 (Python:) 
\end_layout

\begin_layout Itemize

\lang english
$a[25]+5 (Perl:) 
\end_layout

\begin_layout Itemize

\lang english
a[25]+5 (C:) 
\end_layout

\begin_layout Itemize

\lang english
a[25]+5 (ML:) 
\end_layout

\begin_deeper
\begin_layout Itemize
מבחינה סינסטקטית באמת ניתן לראות שכל שפה יש לה את המיוחד שלה )וראקט יוצאת
 דופן(
\end_layout

\begin_layout Itemize
מבחינה סמנטית כולן מקפיצות 
\begin_inset Formula $exception$
\end_inset

 חוץ מ 
\begin_inset Formula $C$
\end_inset

 שבה לא מוגדר מה יקרה
\end_layout

\begin_deeper
\begin_layout Standard
ניתן להוסיף שזה גם מאוד מתאים לאג'נדה של כותבי השפה, באותם ימים היו מעט
 מאוד מתכנתים ורובם היו ברמה גבוה מאוד , והם רצו לתת מה שיותר כח למתכנתים.
 כיום תכנות הוא יותר רווח ואנחנו רוצים להגן על המתכנתים.
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize
איך נגדיר סמנטיקה של שפה?
\end_layout

\begin_deeper
\begin_layout Itemize
אפשרות אחת בעזרת חוקים לוגים
\end_layout

\begin_layout Itemize
על ידי תרגום לשפה אחרת, כלומר על ידי כלי שמתרגם אנחנו יוצקים משמעות לתוכן
 הכתוב, וזהו בעצם קומפיילר )אנחנו נכתוב אינטרפטר(
\end_layout

\begin_deeper
\begin_layout Itemize
לכן נבחרה 
\begin_inset Formula $Racket$
\end_inset

 שהיא מתאימה לעקרונות של הקורס הזה.
\end_layout

\begin_layout Itemize
נעיר שלמרות ש 
\begin_inset Formula $Racket$
\end_inset

יוצאת דופן יש להתייחס לזה ברצינות )הסיפור עם דיקטסרה שטען שצריך לותר על
 
\begin_inset Formula $Goto$
\end_inset

 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsection
\begin_inset Formula $Racket$
\end_inset

 
\end_layout

\begin_layout Subsubsection
בסיס
\end_layout

\begin_layout Itemize
זוהי שפה פונקציונלית
\end_layout

\begin_deeper
\begin_layout Itemize
שפה שמתייחסת לעולם כאבסטרקציה, ללא קשר לאיך הם ממומשים בזיכרון, והקוד 
\begin_inset Quotes eld
\end_inset

מסביר את עצמו
\begin_inset Quotes erd
\end_inset

 כי נדאג שלא יהיה 
\begin_inset Formula $side-effect$
\end_inset

 ותמיד יהיה ערך מוחזר לעבוד איתו )ולא יהיה לנו דברים שקיימים מבחינתנו רק
 בזיכרון(
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Racket$
\end_inset

 שפת בת ל 
\begin_inset Formula $Scheme$
\end_inset

 )התפצלו לאחר ריב בחברה(
\end_layout

\begin_layout Itemize
כל קובץ נתחיל צריך להתחיל בסוג השפה שאני משתמש אצלנו ב:
\end_layout

\begin_deeper
\begin_layout Standard

\lang english
#lang pl
\end_layout

\end_deeper
\begin_layout Itemize
הטיפוסים דינמיים - 
\begin_inset Formula $f$
\end_inset

 יכולה להיות פונקציה ויכולה להיות מחרוזת.
\end_layout

\begin_deeper
\begin_layout Itemize
בפיתוחים החדשים של השפה כבר כן חייבים להגדיר
\end_layout

\begin_layout Itemize
עולם הערכים , הוא אבסטרקטי והיררכי למשל:
\end_layout

\begin_deeper
\begin_layout Itemize
ישנו אובייקט/ערך 
\begin_inset Formula $true$
\end_inset

 וישנו אובייקט/ערך 
\begin_inset Formula $false$
\end_inset

 ואיחוד הערכים יוצר את האובייקט/ערך 
\begin_inset Formula $boolean$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
בעולם של 
\begin_inset Formula $Racket$
\end_inset

 האובייקט היחידי שהוא 
\begin_inset Formula $false$
\end_inset

 ולכן כל דבר אחר למשל כל מספר )ואפילו
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
0
\family roman
\series medium
\shape up
\size normal
\emph off
\numeric off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
( הוא 
\begin_inset Formula $true$
\end_inset

 
\end_layout

\begin_layout Itemize
באופן דומה עבור מספרים .
\end_layout

\begin_layout Itemize
טיפוס 
\begin_inset Formula $string$
\end_inset

 נסמן על ידי 
\begin_inset Formula $".."$
\end_inset


\end_layout

\begin_layout Itemize
טיפוס 
\begin_inset Formula $Symobl$
\end_inset

 נסמן על ידי תו בודד 
\begin_inset Formula $'$
\end_inset

 )רק בהתחלה(
\end_layout

\begin_layout Itemize
תווים 
\begin_inset Formula $Characters$
\end_inset

 : אובייקט למשל התו 
\begin_inset Formula $a$
\end_inset

 יסומן כך: 
\begin_inset Formula $\#\backslash a$
\end_inset


\end_layout

\begin_layout Itemize
וכעת ניתן לעשות פעולות, על ידי הצבת אופרטור/פונקציה משמאל כמו שאנחנו מסמנים
 
\begin_inset Formula $f(x,y)$
\end_inset

 , לדוג': 
\end_layout

\begin_deeper
\begin_layout Standard

\lang english
(string #
\backslash
a #
\backslash
b)
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $null$
\end_inset

 הוא מסוג רשימה ריקה
\end_layout

\begin_layout Itemize
מוסכמה: פונקציות בוליאניות יסומנו ב
\begin_inset Formula $?$
\end_inset

 בסופן למשל:
\end_layout

\begin_deeper
\begin_layout Standard

\lang english
(eq? #
\backslash
a #
\backslash
a) - eq ask if a==a , retrun bool/
\end_layout

\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\align left

\series bold
הרצאה 
\numeric on
2
\numeric off
 
\end_layout

\begin_layout Subsubsection*
\begin_inset Formula $\text{Commetns}$
\end_inset


\end_layout

\begin_layout Standard
מסמנים על ידי 
\begin_inset Formula $;$
\end_inset

 המוסכמה לעשות על ידי פעמיים כלומר 
\begin_inset Formula $;;$
\end_inset

 דוגמה:
\end_layout

\begin_layout LyX-Code

\lang english
;; This is a comment that continues to 
\end_layout

\begin_layout LyX-Code

\lang english
;; the end of the line.
 
\end_layout

\begin_layout LyX-Code

\lang english
; One semi-colon is enough.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
להגדיר בלוק כהערה על ידי 
\begin_inset Formula $\#|$
\end_inset

 בשביל לפתוח ו
\begin_inset Formula $|\#$
\end_inset

 בשביל לסגור )להתחיל מחדש(
\end_layout

\begin_layout LyX-Code

\lang english
#| This is a block comment , which starts 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
with '#|' and ends with a '|# '.
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
|#
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
ביטוי בודד על ידי 
\begin_inset Formula $\#;$
\end_inset

 
\end_layout

\begin_layout LyX-Code

\lang english
#;( comment out a single form )
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsubsection
ביטויי תנאי
\end_layout

\begin_layout LyX-Code

\lang english
There are two Boolean values built-in in Racket: 
\end_layout

\begin_layout LyX-Code

\lang english
`#t' (true) and `#f' (false).
  
\end_layout

\begin_layout Standard
\begin_inset Formula $if$
\end_inset

 :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
(\underbrace{if}_{\text{oper'}}(\underbrace{<\ 2\ 3}_{\text{cond'}})\underbrace{10}_{\text{true}}\underbrace{20}_{\text{false}})-->10
\]

\end_inset


\end_layout

\begin_layout Standard
דוגמה:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{matrix}(\underbrace{if}_{\text{oper'}}(\underbrace{"false"}_{\text{cond'}}\underbrace{1}_{\text{true}}\underbrace{2}_{\text{false}})-->1\\
\\
(\underbrace{if}_{\text{oper'}}\underbrace{null}_{\text{cond'}}\underbrace{1}_{\text{true}}\underbrace{2}_{\text{false}})-->1
\end{matrix}
\]

\end_inset


\end_layout

\begin_layout Standard
הסבר: ה
\begin_inset Formula $string$
\end_inset

 , 
\begin_inset Formula $"false"$
\end_inset

 ו 
\begin_inset Formula $null$
\end_inset

 הם 
\begin_inset Formula $\#t$
\end_inset

 כפי שהסברנו לעיל.
 רק:
\begin_inset Formula 
\[
(\underbrace{if}_{\text{oper'}}\underbrace{\#f}_{\text{cond'}}\underbrace{1}_{\text{true}}\underbrace{2}_{\text{false}})-->2
\]

\end_inset


\end_layout

\begin_layout Standard
ב
\begin_inset Formula $PL$
\end_inset

 חייבים תמיד להחזיר ערך כלשהו )שפה פונקציאלית ולכן הביטוי הבא אינו תקין:
\end_layout

\begin_layout LyX-Code

\lang english
  (if test consequent)
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Cond$
\end_inset


\end_layout

\begin_layout Standard
התניה מקוננת , ב
\begin_inset Formula $Java$
\end_inset

 אנחנו מכירים זאת כ 
\begin_inset Formula $else\ if$
\end_inset

 , ב
\begin_inset Formula $Rackt$
\end_inset

 זה לא נח ולא מסתדר עם ההזחות, ולכן המציאו את המילה 
\begin_inset Formula $cond$
\end_inset

 
\end_layout

\begin_layout Standard
תהליך זה נקרא 
\begin_inset Formula $\text{syntactic sugar}$
\end_inset

: תהליך שבו יש לי בשפה פתרון לפעולה מסוימת אבל אני רוצה ל
\begin_inset Quotes erd
\end_inset

המתיק
\begin_inset Quotes erd
\end_inset

 את חיי ולכן ממציא תחביר חלופי שעושה את אותו דבר.
\end_layout

\begin_layout Standard
דוגמה:
\end_layout

\begin_layout LyX-Code

\lang english
(define (digit-num n)
\end_layout

\begin_layout LyX-Code

\lang english
    (cond [(<= n 9)    1]
\end_layout

\begin_layout LyX-Code

\lang english
          [(<= n 99)   2]
\end_layout

\begin_layout LyX-Code

\lang english
          [(<= n 999)  3]
\end_layout

\begin_layout LyX-Code

\lang english
          [(<= n 9999) 4]
\end_layout

\begin_layout LyX-Code

\lang english
          [else        "a lot"])) 
\end_layout

\begin_layout Standard
סדר הפעולות: בודקים את התנאי הראשון, אם 
\begin_inset Formula $True$
\end_inset

 מחזירים את הערך שלו, אחרת בודקים את התנאי השני, וכו'...
 בגלל שחייבים להחזיר ערך, 
\series bold
חייב
\series default
 להיות 
\begin_inset Formula $else$
\end_inset


\end_layout

\begin_layout Subsubsection
רשימות
\end_layout

\begin_layout Standard
אובייקט שמגודר באופן רקוריסיבי:
\end_layout

\begin_layout Itemize
רשימה ריקה - 
\begin_inset Formula $null\equiv()$
\end_inset


\end_layout

\begin_layout Itemize
או זוג 
\begin_inset Formula $\left(pair\right)$
\end_inset

 שהאיבר השני בו הוא רשימה.
\end_layout

\begin_layout Standard
מה זה 
\begin_inset Formula $pair$
\end_inset

 ? זה זוג שנוצר בעקבות הפקודה 
\begin_inset Formula $cons$
\end_inset

 למשל:
\end_layout

\begin_layout Standard
\align center
פקודה זו לא ניתן להריץ ב 
\begin_inset Formula $PL$
\end_inset

 , 
\begin_inset Formula $\text{(cons 1 2)}\longrightarrow\begin{array}{|c|c|}
\hline 1 & 2\\\hline \end{array}$
\end_inset


\end_layout

\begin_layout Standard
ב
\begin_inset Formula $PL$
\end_inset

 נגדיר רשימה כך:
\begin_inset Formula $\text{(list 1 2 3)}$
\end_inset


\end_layout

\begin_layout Standard
וע
\begin_inset Quotes erd
\end_inset

פ ההגדרה המימוש של זה הוא כך:
\begin_inset Formula $\begin{array}{|c|c|}
\hline 1 & \begin{array}{|c|c|}
\hline 2 & \begin{array}{|c|c|}
\hline 3 & null\\\hline \end{array}\\
 & \\
\hline \end{array}\\
 & \\
\hline \end{array}$
\end_inset


\end_layout

\begin_layout Standard
ניתן להסתכל על זה בצורה יותר מוכרת: 
\begin_inset Formula $\begin{array}{|c|c|}
\hline 1 & \cdot\\\hline \end{array}\rightarrow\begin{array}{|c|c|}
\hline 2 & \cdot\\\hline \end{array}\rightarrow\begin{array}{|c|c|}
\hline 3 & null\\\hline \end{array}$
\end_inset


\end_layout

\begin_layout Standard
לכן הוספת איבר ראשון משמאל , קל מאוד: 
\begin_inset Formula $\text{(cons 0 (list 1 2 3))}$
\end_inset

 )גם ההסרה פשוטה(
\end_layout

\begin_layout Standard
הערה: הפקודה
\begin_inset Formula $\text{( list 1 2 3 null ) }$
\end_inset

 היא אובייקט שהזוג האחרון בו הוא 
\begin_inset Formula $\begin{array}{|c|c|}
\hline null & null\\\hline \end{array}=\begin{array}{|c|c|}
\hline '() & '()\\\hline \end{array}$
\end_inset

 
\end_layout

\begin_layout Standard

\bar under
פונקציות על רשימות
\end_layout

\begin_layout Standard
\begin_inset Formula $append$
\end_inset


\end_layout

\begin_layout LyX-Code

\lang english
( append ( list 1 2) null ) ; = > '(1 2)
\end_layout

\begin_layout LyX-Code

\lang english
( append ( list 1 2) ( list 3 4) ) ; = > '(1 2 3 4)
\end_layout

\begin_layout Standard
גישה ניתן לגשת על ידי 
\begin_inset Formula $first,second,third$
\end_inset

 לשלושת המקומות הראשונים.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $rest$
\end_inset

 זה ההמשך של הרשימה.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $list-ref$
\end_inset

 - גישה לפי אינדקס
\end_layout

\begin_layout LyX-Code

\lang english
( first ( list 1 2 3) ) ; = > 1 
\end_layout

\begin_layout LyX-Code

\lang english
( rest ( list 1 2 3) ) ; = > '(2 3)
\end_layout

\begin_layout LyX-Code

\lang english
( list-ref '(1 2 3) 2) ; = > 3
\end_layout

\begin_layout LyX-Code

\lang english
   
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset Formula $define$
\end_inset

 
\end_layout

\begin_layout Standard
מאפשר לנו לעשות 
\begin_inset Formula $\text{binding}$
\end_inset

 בן שם מזהה לערך, נזכיר שאנחנו מתעסקים ב 
\begin_inset Formula $Static-typing$
\end_inset

 ולכן תמיד צריך להגדיר מהו סוג הערך.
 
\end_layout

\begin_layout Standard
נעשה זאת על ידי נקודתיים לפני ואחרי
\end_layout

\begin_layout Standard
דוגמאות:
\end_layout

\begin_layout LyX-Code

\lang english
(: PI : Real)
\end_layout

\begin_layout LyX-Code

\lang english
( define PI 3.14) 
\end_layout

\begin_layout Standard
ומעתה יש לנו 
\begin_inset Quotes eld
\end_inset

קבוע
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $PI$
\end_inset

 , דוגמה נוספת :
\end_layout

\begin_layout Standard
הסבר: השם
\bar under
 
\begin_inset Formula $length$
\end_inset

 
\bar default
מקושר לאובייקט מסוג 
\bar under
פונקציה
\bar default
 )בגלל החץ( 
\bar under
שמקבלת רשימה
\bar default
 של 
\begin_inset Formula $Any$
\end_inset

 ו
\bar under
מחזירה מספר
\bar default
 טבעי
\end_layout

\begin_layout Standard
הפוקציה מחזירה את אורך הרשימה
\end_layout

\begin_layout LyX-Code

\lang english
(: length : ( Listof Any ) - > Natural ) 
\end_layout

\begin_layout LyX-Code

\lang english
( define ( length l )
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
( cond [( null ? l ) 0] 
\end_layout

\begin_layout LyX-Code

\lang english
[ else ( add1 ( length ( rest l ) ) ) ]) )
\end_layout

\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\bar under
למה 
\begin_inset Formula $Static-typing$
\end_inset

 ?
\end_layout

\begin_layout Itemize
לשמור על המתכנת
\end_layout

\begin_layout Itemize
עוזר לפונקציה 
\begin_inset Quotes eld
\end_inset

לכתוב את עצמה
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
הופך את הקוד לקריא יותר.
\end_layout

\begin_layout Standard
\begin_inset Formula $define-type$
\end_inset

 
\end_layout

\begin_layout Standard
הזכרנו שניתן להגדיר אובייקט , דוגמה:
\end_layout

\begin_layout LyX-Code

\lang english
( define-type Animal 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[ Snake Symbol Number Symbol ] 
\end_layout

\begin_layout LyX-Code

\lang english
[ Tiger Symbol Number ])
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
ניתן להתייחס ל 
\begin_inset Formula $Snake,Tiger$
\end_inset

 כבנאים של האובייקט 
\begin_inset Formula $Animal$
\end_inset

 שמקבלים ערכים ומחזרים אובייקט כזה מסוג 
\begin_inset Formula $Animl$
\end_inset

 
\end_layout

\begin_layout Standard
כעת גם יש לנו פונקציה 
\begin_inset Formula $Animal?$
\end_inset

 ששואלת האם אובייקט הוא מסוג 
\begin_inset Formula $Animal$
\end_inset

 
\end_layout

\begin_layout LyX-Code

\lang english
( Animal ? ( Snake 'Slimey 10 'rats ) ) ; = > #t 
\end_layout

\begin_layout LyX-Code

\lang english
( Animal ? ( Tiger 'Tony 12) ) ; = > #t 
\end_layout

\begin_layout LyX-Code

\lang english
( Animal ? 10) ; = > #f
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\bar under
\begin_inset Formula $Cases$
\end_inset


\end_layout

\begin_layout Standard
פונקציה שמאפשרת לאובייקט מסוג 
\begin_inset Formula $Animal$
\end_inset

 ולבדוק איך בנינו אותו, לדוגמה:
\end_layout

\begin_layout LyX-Code

\lang english
( cases ( Snake 'Slimey 10 'rats ) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[( Snake n w f ) n ] 
\end_layout

\begin_layout LyX-Code

\lang english
[( Tiger n sc ) n ])
\end_layout

\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Itemize
מי זה 
\begin_inset Formula $n$
\end_inset

 ? הפונקציה מיצרת 
\begin_inset Formula $binding$
\end_inset

 בין הערך לסוג האובייקט ולכן במקרה הזה 
\begin_inset Formula $n='Slimey$
\end_inset

 )
\begin_inset Formula $w=10,f='rats$
\end_inset

(
\end_layout

\begin_layout Itemize
האם צריך 
\begin_inset Formula $else$
\end_inset

 )כמו ב 
\begin_inset Formula $cond$
\end_inset

 ( ? בגלל שפה אנחנו יודעים בדיוק מי הבנאים שלו אז ניתן לותר עליו, אבל יש
 מקרים שכן נוסיף
\end_layout

\begin_layout Standard
המשך הדוגמה:
\end_layout

\begin_layout LyX-Code

\lang english
(: animal-name : Animal - > Symbol ) 
\end_layout

\begin_layout LyX-Code

\lang english
( define ( animal-name a )
\end_layout

\begin_layout LyX-Code

\lang english
( cases a 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[( Snake n w f ) n ] 
\end_layout

\begin_layout LyX-Code

\lang english
[( Tiger n sc ) n ]) )
\end_layout

\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
הסבר:
\end_layout

\begin_layout Itemize
קראנו לפונקציה בשם 
\begin_inset Formula $animal-name$
\end_inset

 , שלוקחת 
\begin_inset Formula $Animal$
\end_inset

 ומחזירה 
\begin_inset Formula $Symbol$
\end_inset

 
\end_layout

\begin_layout Itemize
כעת בשביל לדעת מהו האובייקט שקיבלנו נשתמש ב: 
\begin_inset Formula $Cases$
\end_inset

 
\end_layout

\begin_layout Subsubsection
\begin_inset Formula $All$
\end_inset


\end_layout

\begin_layout LyX-Code

\lang english
(: every ? : ( All ( A ) ( A - > Boolean ) ( Listof A ) - > Boolean ) )
\end_layout

\begin_layout Standard
הגדרנו מעין 
\begin_inset Formula $Template$
\end_inset

 , כלומר אתה לא חייב להחליט כרגע מהוא 
\begin_inset Formula $A$
\end_inset

 אבל כשהחלטת, הפונקציה 
\begin_inset Formula $every$
\end_inset

 תצפה לקבל את אותו אובייקט לשאר הפונקציות
\end_layout

\begin_layout Standard
לדוגמה 
\begin_inset Formula $A$
\end_inset

 הוא 
\begin_inset Formula $Natural$
\end_inset

 אז 
\begin_inset Formula $every$
\end_inset

 מצפה לקבל פונקציות מסוג: 
\begin_inset Formula $\left\{ \begin{matrix}Natural\rightarrow Boolean\\
ListOf\ Natrual\rightarrow Boolean
\end{matrix}\right\} $
\end_inset


\end_layout

\begin_layout Subsection
דקדוקים חסרי-הקשר 
\end_layout

\begin_layout Subsubsection
השפה הבסיסית 
\begin_inset Formula $AE$
\end_inset


\end_layout

\begin_layout Standard
כעת נתחיל לבנות את השפה שלנו, וצריך להתחיל להגדיר את הדקדוק שלה, נניח שאנחנו
 רוצים להגדיר שפה של מספרים ופעולות חיבור/חיסור.
 אז התחביר שלנו יהיה לפי
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
3
\family roman
\series medium
\shape up
\size normal
\emph off
\numeric off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
כללים:
\end_layout

\begin_layout LyX-Code

\lang english
1) <AE> ::= <num>
\end_layout

\begin_layout LyX-Code

\lang english
2)       | <AE> + <AE>
\end_layout

\begin_layout LyX-Code

\lang english
3)       | <AE> - <AE> 
\end_layout

\begin_layout Standard
כלל
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
1
\family roman
\series medium
\shape up
\size normal
\emph off
\numeric off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
אומר שמ 
\begin_inset Formula $AE$
\end_inset

 ניתן לגזור כל מספר - זה כאילו הגדרנו אינסוף כללים לגזירת כל המספרים.
\end_layout

\begin_layout Standard
פורמלית ניתן להגדיר, כלל נוסף:
\end_layout

\begin_layout LyX-Code

\lang english
  <NUM> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
\end_layout

\begin_layout LyX-Code

\lang english
          | <NUM> <NUM> 
\end_layout

\begin_layout Standard
אז מהי השפה? השפה היא כל דבר שניתן לגזור מ 
\begin_inset Formula $non-terminal$
\end_inset

 המרכזי.
 דוגמה נגזור מ
\begin_inset Formula $AE$
\end_inset

 את 
\begin_inset Formula $1-2+3$
\end_inset

 :
\end_layout

\begin_layout LyX-Code

\lang english
<AE>		        ;		==>   
\end_layout

\begin_layout LyX-Code

\lang english
<AE> + <AE>         ; (2)	==>   
\end_layout

\begin_layout LyX-Code

\lang english
<AE> + <num>        ; (1)	==>
\end_layout

\begin_layout LyX-Code

\lang english
<AE> - <AE> + <num> ; (3)	==>
\end_layout

\begin_layout LyX-Code

\lang english
<AE> - <AE> + 3     ; (num)	==>
\end_layout

\begin_layout LyX-Code

\lang english
<num> - <AE> + 3    ; (1)	==>
\end_layout

\begin_layout LyX-Code

\lang english
<num> - <num> + 3   ; (1)	==>
\end_layout

\begin_layout LyX-Code

\lang english
1 - <num> + 3       ; (num)	==>
\end_layout

\begin_layout LyX-Code

\lang english
1 - 2 + 3           ; (num)	 
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
הבעיה שעץ הגזירה הוא לא בהכרח יחיד, וכאשר אנחנו מילה/ביטוי אנחנו לא יודעים
 מאיזה עץ היא הגיע.
 
\begin_inset Formula $\left(Ambiguity\right)$
\end_inset

 -אנחנו לא אוהבים בעולם התכנות.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename prog-lang-picture/less01_01.png
	scale 80

\end_inset


\end_layout

\begin_layout Standard
והבעיה נוספת היא בעיה 
\series bold
סמנטית
\series default
 - שלמשל בעבור
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
גזירות שונות נקבל תוצאות שונות )סדר הפעולות חשבון( = דו משמעות :
\end_layout

\begin_layout Standard
\align center
\begin_inset Formula $-4=1-2+3=2$
\end_inset

 
\end_layout

\begin_layout Standard
לכן נחייב את הדקדוק לגזור את האיבר הראשון למספר, כלומר:
\end_layout

\begin_layout LyX-Code

\lang english
1) <AE> ::= <num>
\end_layout

\begin_layout LyX-Code

\lang english
2)       | <num> + <AE>
\end_layout

\begin_layout LyX-Code

\lang english
3)       | <num> - <AE> 
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
ובכך יצרנו עץ 
\begin_inset Formula $\text{Left association}$
\end_inset

 והוא יחיד ובטלנו את הדו-משמעות.
\end_layout

\begin_layout Standard
נמשיך לפתח - קדימות לכפל תמומש בכך שכפל יהיה רק בתחתית העץ, ובשביל זה נגדיר:
\end_layout

\begin_layout LyX-Code

\lang english
  <AE>  ::= <num>           
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
| <AE> + <AE>
\end_layout

\begin_layout LyX-Code

\lang english
| <FAC>
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
  <FAC> ::= <num>           
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
| <FAC> * <FAC> 
\end_layout

\end_deeper
\begin_layout Standard
נמשיך לפתח - הוספת סוגריים )ואז ביטלנו את הדיון הקודם( שבא מכריחים להגדיר
 קדימויות, בהתאמה ל
\begin_inset Formula $Racket$
\end_inset

 זה יראה כך:
\end_layout

\begin_layout LyX-Code

\lang english
  <AE> ::= <num>          
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
| { + <AE> <AE> }
\end_layout

\begin_layout LyX-Code

\lang english
| { - <AE> <AE> }
\end_layout

\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
ולמשל :
\end_layout

\begin_layout LyX-Code

\lang english
{+ 5 6}--> 11
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\align left

\series bold
הרצאה 
\numeric on
3
\numeric off
 
\end_layout

\begin_layout Standard
בשיעור שעבר הגדרנו את הדקדוק:
\end_layout

\begin_layout LyX-Code

\lang english
  <AE> ::= <num>          
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
| { + <AE> <AE> }
\end_layout

\begin_layout LyX-Code

\lang english
| { - <AE> <AE> }
\end_layout

\end_deeper
\begin_layout Standard
בעזרת הדקדוק אנחנו בודקים אילו 
\begin_inset Quotes eld
\end_inset

תוכניות
\begin_inset Quotes erd
\end_inset

 קבילות בשפה שלנו, נראה בדוגמה:
\end_layout

\begin_layout Standard
\align center
\begin_inset Formula $\left(-\left(+\ 3\ 4\right)2\right)$
\end_inset


\begin_inset Formula 
\[
\begin{matrix}\left\langle AE\right\rangle \\
\begin{matrix} & \swarrow & \downarrow & \searrow\\
\boldsymbol{\{} & \boldsymbol{-} & \left\langle AE\right\rangle  & \left\langle AE\right\rangle  & \boldsymbol{\}}\\
 &  & \begin{matrix}\swarrow & \downarrow & \searrow\end{matrix} & \downarrow\\
 &  & \left\{ \begin{matrix}\boldsymbol{+} & \boldsymbol{\left\langle 3\right\rangle } & \boldsymbol{\left\langle 4\right\rangle }\end{matrix}\right\}  & \boldsymbol{\left\langle 2\right\rangle }
\end{matrix}
\end{matrix}
\]

\end_inset


\end_layout

\begin_layout Standard
כעת נרצה לכתוב את האינטרפטר )לקבל את המשמעות(, אבל נתחיל מלעשות 
\begin_inset Formula $parsing$
\end_inset

 , והאתגר הוא שצריך להחזיק מבנה נתונים, שיודע לסנן את המידע הלא חשוב.
 בדוגמה למשל 
\begin_inset Formula $3+4$
\end_inset

 מבחינתנו יכול להיות גם 
\begin_inset Formula $4+3$
\end_inset

 , ולמשל המידע שדוקא
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
3
\family roman
\series medium
\shape up
\size normal
\emph off
\numeric off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 ראשון, לא חיוני.
 ולכן נרצה לבנות: 
\begin_inset Formula $\text{abstract syntax tree}$
\end_inset


\end_layout

\begin_layout Standard
המשך הדוגמה - בצורה אבסטרקטית נרצה ש
\end_layout

\begin_layout Standard
\align center
\begin_inset Formula 
\[
\begin{matrix}\left\langle Sub\right\rangle \\
\begin{matrix}\swarrow & \searrow\\
\left\langle Add\right\rangle  & \boldsymbol{\left\langle Num\ 2\right\rangle }\\
\begin{matrix}\swarrow &  & \searrow\end{matrix}\\
\left\{ \begin{matrix}\boldsymbol{+} & \boldsymbol{\left\langle Num\ 3\right\rangle } & \boldsymbol{\left\langle Num\ 4\right\rangle }\end{matrix}\right\} 
\end{matrix}
\end{matrix}
\]

\end_inset


\end_layout

\begin_layout Standard
וכעת לא משנה לנו האם:
\end_layout

\begin_layout Itemize

\lang english
3+4 (infix), 
\end_layout

\begin_layout LyX-Code

\lang english
3 4 + (postfix), 
\end_layout

\begin_layout Itemize

\lang english
+(3,4) (prefix with operands in parens), 
\end_layout

\begin_layout Itemize

\lang english
(+ 3 4) (parenthesized prefix), 
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
נדגים ב 
\begin_inset Formula $DrRacket$
\end_inset

 בניה של מבנה נתונים כזה:
\end_layout

\begin_layout Itemize
במהלך התוכנית נעזר בפונקציה 
\begin_inset Formula $\text{string->sexpr}$
\end_inset

 שמקבלת 
\begin_inset Formula $string$
\end_inset

 ומחזירה אובייקט 
\begin_inset Formula $sexpr$
\end_inset

 )כאשר הוא נתקל בסוגריים הוא מחשיב כתא אחד(
\end_layout

\begin_layout Itemize
נבנה טיפוס 
\begin_inset Formula $AE$
\end_inset


\end_layout

\begin_layout Itemize
נבנה פונקציה רקרוסיבית שתפרסר ביטוי:
\end_layout

\begin_layout LyX-Code

\lang english
#lang pl 
\end_layout

\begin_layout LyX-Code

\lang english
(define-type AE
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[Num Number]     
\end_layout

\begin_layout LyX-Code

\lang english
[Add AE AE]     
\end_layout

\begin_layout LyX-Code

\lang english
[Sub AE AE])
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(: parse-sexpr : Sexpr -> AE)   
\end_layout

\begin_layout LyX-Code

\lang english
(define (parse-sexpr expr)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(cond      
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(number? expr) (Num expr)]      
\end_layout

\begin_layout LyX-Code

\lang english
[(and (list? expr) (= (length expr) 3) (equal? (first expr ) '+))
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(Add (parse-sexpr(second expr)) (parse-sexpr(third expr)))]      
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
[(and (list? expr) (= (length expr) 3) (equal? (first expr ) '-))
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(Sub (parse-sexpr(second expr)) (parse-sexpr(third expr)))]      
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
[else (error 'parse-sexpr "bad syntax in ~s" expr)]
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\lang english
))
\end_layout

\begin_layout LyX-Code

\lang english
(: parse : String -> AE)
\end_layout

\begin_layout LyX-Code

\lang english
(define (parse code)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(parse-sexpr(string->sexpr code)))
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(test (parse "5") => (Num 5)) 
\end_layout

\begin_layout LyX-Code

\lang english
(test (parse "{ + 3 4}") => (Add (Num 3) (Num 4))) 
\end_layout

\begin_layout LyX-Code

\lang english
(test (parse "{- { + 3 4 } 5 }") => (Sub (Add (Num 3) (Num 4)) (Num 5)))
 
\end_layout

\begin_layout LyX-Code

\lang english
(test (parse "{+ 4 5 { - 4 5 4 5 4 5 }}") =error> "bad syntax")
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code

\bar under
\lang english
result
\bar default
:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
4 tests passed.
 
\end_layout

\end_deeper
\begin_layout Subsubsection
פונקציית 
\begin_inset Formula $match$
\end_inset


\end_layout

\begin_layout Standard
הקוד יצא לנו יחסית ארוך, ונרצה לקצר על ידי שימוש בפונקציה 
\begin_inset Formula $match$
\end_inset

 , דוגמת שימוש:
\end_layout

\begin_layout LyX-Code

\lang english
(match var       
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
['x "yes"]
\end_layout

\begin_layout LyX-Code

\lang english
[else "no"]) 
\end_layout

\end_deeper
\begin_layout Standard
דוגמה נוספת, בנוסף לבדיקת התאמה אני מחליט איך לקרוא למשתנים ומבצע את הפעולה
 שאני רוצה:
\end_layout

\begin_layout LyX-Code

\lang english
(match (list 1 2 3)     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(list x y z) (+ x y z)]) ; evaluates to 6   
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(match '((1) (2) 3)     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(list (list x) (list y) z) (+ x y z)]) ; evaluates to 6 
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
match '((1 2) (3 4) (5 6) (7 8))     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(list (list x y) ...) (append x y)])  ; evaluates to (1 3 5 7 2 4 6 8) 
\end_layout

\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
בדוגמה האחרונה 
\begin_inset Formula $x,y$
\end_inset

 כ
\begin_inset Quotes erd
\end_inset

א הן רשימה, והשלוש נקודות אומר לך להמשיך לשאר המערך , ובסוף נקבל שרשור של
 כל המערכים.
 התנאי של ה 
\begin_inset Formula $match$
\end_inset

 יכול להיות אחד מ:
\end_layout

\begin_layout Itemize

\series bold
\lang english
id
\series default
 -- matches anything, binds `id' to it
\end_layout

\begin_layout Itemize

\series bold
\lang english
_
\series default
 -- matches anything, but does not bind 
\end_layout

\begin_layout Itemize

\lang english
(number: n) -- matches any number and binds it to `n' 
\end_layout

\begin_layout Itemize

\lang english
(symbol: s) -- same for symbols (string: s) -- strings 
\end_layout

\begin_layout Itemize

\lang english
(sexpr: s) -- S-expressions (needed sometimes for Typed Racket) 
\end_layout

\begin_layout Itemize

\lang english
(and pat1 pat2) -- matches both patterns 
\end_layout

\begin_layout Itemize

\lang english
(or pat1 pat2) -- matches either pattern (careful with bindings) 
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
וכעת נחליף בקוד שלנו את 
\begin_inset Formula $cond$
\end_inset

 ב
\begin_inset Formula $match$
\end_inset

 ונקבל:
\end_layout

\begin_layout LyX-Code

\lang english
(: parse-sexpr : Sexpr -> AE)   
\end_layout

\begin_layout LyX-Code

\lang english
(define (parse-sexpr expr)     
\end_layout

\begin_layout LyX-Code

\lang english
(match expr      
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(number: n ) (Num n)]      
\end_layout

\begin_layout LyX-Code

\lang english
[ ( list '+ l r) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(Add (parse-sexpr(l)) (parse-sexpr(r)))]      
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
[ ( list '- l r) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(Sub (parse-sexpr(l)) (parse-sexpr(r)))]      
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
[else (error 'parse-sexpr "bad syntax in ~s" expr)]
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
))
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
כעת נרצה שהקוד שלך יעריך )=יחשב( את הביטויים , כלומר לברר את המשמעות שלהם:
\end_layout

\begin_layout LyX-Code

\lang english
#| eval's Foramlization  
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
eval(N) = N  
\end_layout

\begin_layout LyX-Code

\lang english
eval (+ E1 E2) = eval(E1) + eval(E2)  
\end_layout

\begin_layout LyX-Code

\lang english
eval (- E1 E2) = eval(E1) - eval(E2) 
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
|#
\end_layout

\begin_layout LyX-Code

\lang english
(: eval : Sexpr -> Number)   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (eval expr)     
\end_layout

\begin_layout LyX-Code

\lang english
(match expr
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(number: n ) n]
\end_layout

\begin_layout LyX-Code

\lang english
[(list '+ l r) (+ (eval l) (eval r))]
\end_layout

\begin_layout LyX-Code

\lang english
[(list '- l r) (- (eval l) (eval r))]
\end_layout

\begin_layout LyX-Code

\lang english
[else (error 'eval "bad syntax in ~s" expr)]
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
))
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(: run : String -> Number)
\end_layout

\begin_layout LyX-Code

\lang english
(define (run code)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(eval (string->sexpr code)))
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(test (run "5") => 5 )
\end_layout

\begin_layout LyX-Code

\lang english
(test (run "{ + 3 4}") => 7)
\end_layout

\begin_layout LyX-Code

\lang english
(test (run "{- { + 3 4 } 5 }") => 2)
\end_layout

\begin_layout LyX-Code

\lang english
(test (run "{+ 4 5 { - 4 5 4 5 4 5 }}") =error> "bad syntax")
\end_layout

\begin_layout LyX-Code

\bar under
\lang english
result
\bar default
:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
4 tests passed.
\end_layout

\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
מה החיסרון של הקוד הזה?
\end_layout

\begin_layout Itemize
שיש לנו ערבוב בין הפעולות הנדרשות: להבין את הביטוי ולחשב אותו, ואנחנו נעדיף
 להפריד בינהם.
\end_layout

\begin_layout Itemize
איך זה יעזור?
\end_layout

\begin_deeper
\begin_layout Itemize
לדוגמה מצאנו דרך יעילה יותר לחשב, לא צריך לשנות את כל הקוד, אלא רק את החלק
 שמחשב
\end_layout

\begin_layout Itemize
לדוגמה מחליטים לשנות את מבנה הביטויים, אז משנים רק אותו והחישוב עומד בפני
 עצמו
\end_layout

\end_deeper
\begin_layout Itemize
בשיעור הבא נראה מימוש נכון של 
\begin_inset Formula $eval$
\end_inset

 .
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\align left

\series bold
הרצאה 
\numeric on
4
\numeric off
 
\end_layout

\begin_layout Standard
תזכורות
\end_layout

\begin_layout Standard

\bar under
דוגמה ל 
\begin_inset Formula $Ambiguity$
\end_inset

 :
\end_layout

\begin_layout Standard

\lang english
eval(1 - 2 + 3) = eval(1 - 2) + eval(3) [b] = eval(1) - eval(2) + eval(3)
 [c] = 1 - 2 + 3 [a,a,a] = 2
\end_layout

\begin_layout Standard

\lang english
eval(1 - 2 + 3) = eval(1) - eval(2 + 3) [c] = eval(1) - (eval(2) + eval(3))
 [a] = 1 - (2 + 3) [a,a,a] = -4 
\end_layout

\begin_layout Standard
וברור שאנחנו לא יכולים להרשות לעצמנו בדקדוק שאנחנו בונים, פתרנו זאת על ידי
 סוגריים.
\end_layout

\begin_layout Subsubsection
\begin_inset Formula $\text{Compositionality }$
\end_inset


\end_layout

\begin_layout Standard
תכונה חשובה נוספת היא 
\begin_inset Formula $\text{Compositionality }$
\end_inset


\end_layout

\begin_layout Standard
נסביר זאת דרך דוגמה והבעיה הבא:
\end_layout

\begin_layout Standard
נניח שיש לנו דקדוק:
\end_layout

\begin_layout Standard

\lang english
<NUM> ::= <digit> <NUM>|<digit> 
\end_layout

\begin_layout Standard

\lang english
<digit> ::= 0|1|....|9
\end_layout

\begin_layout Standard
למשל המספר 
\begin_inset Formula $871$
\end_inset

 ייוצג כך:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename prog-lang-picture/less04_01.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
כעת נניח שהיינו רוצים לכתוב פונקציה שמחזירה את הערך של הביטוי, לכן יתקיים
 ש:
\end_layout

\begin_layout Standard
\align center

\lang english
eval(0)=0,eval(1)=1 .....
\end_layout

\begin_layout Standard
וכנראה שאם היינו מגדירים מספר כללי היינו מנסים:
\end_layout

\begin_layout Standard
\align center

\lang english
eval
\begin_inset Formula $\left(\left\langle digit\right\rangle \left\langle Num\right\rangle \right)=eval\left(\left\langle digit\right\rangle \right)+eval\left(\left\langle Num\right\rangle \right)$
\end_inset

 
\end_layout

\begin_layout Standard
הבעיה שהמחרוזת 
\begin_inset Formula $17$
\end_inset

 היא לא הסכום של 
\begin_inset Formula $1+7$
\end_inset

 ובשביל לפתור את זה, צריך את הנוסחה הבאה:
\end_layout

\begin_layout Standard
\align center
\begin_inset Formula $eval\left(17\right)=10*eval\left(1\right)+eval\left(7\right)$
\end_inset


\end_layout

\begin_layout Standard
נשים לב שאם נגדיר את הנוסחה הזו בצורה רקורסיבית עדיין יש לנו בעיה, נראה
 זאת בעזרת העץ:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename prog-lang-picture/less04_02.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
וברור ש 
\begin_inset Formula $eval\left(871\right)\neq151$
\end_inset

 לכן צריך לשפר גם את הנוסחה הזו.
\end_layout

\begin_layout Standard
מסקנה נשכלל את הנוסחה, ויתקיים ש:
\end_layout

\begin_layout Standard
\align center
\begin_inset Formula $\begin{matrix}eval\left(871\right)=10^{2}*8+10^{1}*7+10^{0}*1=871\end{matrix}$
\end_inset

 
\end_layout

\begin_layout Standard
השיפור שהחזקה תהיה לפי גובה העץ, הבעיה שחישוב כזה הוא 
\begin_inset Quotes eld
\end_inset

מורכב
\begin_inset Quotes erd
\end_inset

 , כלומר דורש 
\series bold
חישובים התלויים בעץ כולו 
\series default
ואנחנו רוצים שהחישוב יהיה מקומי כלומר ש
\begin_inset Formula $Num$
\end_inset

 ידע לחשב זאת ללא תלות בעץ ואם נצליח נקיים את ה 
\begin_inset Formula $\text{Compositionality }$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
הגדרה פורמלית 
\begin_inset Formula $\text{Compositionality }$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula $eval$
\end_inset

 על קודקוד 
\begin_inset Formula $T$
\end_inset

 עם בנים 
\begin_inset Formula $T_{1},..T_{k}$
\end_inset

 יבצע :
\end_layout

\begin_layout Standard
א.
 
\begin_inset Formula $v_{1}=eval\left(T_{1}\right),v_{2}=eval\left(T_{2}\right)....v_{k}=eval\left(T_{k}\right)$
\end_inset

 
\end_layout

\begin_layout Standard
ב.
 יבצע פעולה מקומית על 
\begin_inset Formula $v_{1},...,v_{k}$
\end_inset

 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
עכשיו אם נחזור לדוגמה שלנו, נוכל לעשות שיפוץ קל ולהרויח את התכונה הנ
\begin_inset Quotes erd
\end_inset

ל )נחליף מיקום של 
\begin_inset Formula $digit$
\end_inset


\begin_inset Formula $\Leftrightarrow$
\end_inset

 העץ משוך שמאלה:
\end_layout

\begin_layout Standard

\lang english
<NUM> ::= <NUM><digit> | <digit>|
\end_layout

\begin_layout Standard

\lang english
<digit> ::= 0|1|....|9
\end_layout

\begin_layout Standard
ונקבל ש:
\end_layout

\begin_layout Standard

\lang english
eval
\begin_inset Formula $\left(\left\langle digit\right\rangle \right)=\left\langle digit\right\rangle $
\end_inset


\end_layout

\begin_layout Standard

\lang english
eval
\begin_inset Formula $\left(\left\langle Num\right\rangle \left\langle digit\right\rangle \right)=eval\left(Num\right)+10*eval\left(\left\langle digit\right\rangle \right)$
\end_inset


\end_layout

\begin_layout Standard
נשים לב שכל הפעולות הן מקומיות 
\begin_inset Formula $\left(eval,*10\right)$
\end_inset

 והעץ יראה כך:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename prog-lang-picture/less04_03.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\align center
ואכן 
\begin_inset Formula $eval\left(871\right)=871$
\end_inset

 , כנדרש.
\end_layout

\begin_layout Standard

\bar under
תזכורת קצרה אחרונה
\bar default
, בשיעור שעבר הגענו לקוד הבא:
\end_layout

\begin_layout LyX-Code

\lang english
(: eval : Sexpr -> Number)   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (eval expr)     
\end_layout

\begin_layout LyX-Code

\lang english
(match expr
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(number: n ) n]
\end_layout

\begin_layout LyX-Code

\lang english
[(list '+ l r) (+ (eval l) (eval r))]
\end_layout

\begin_layout LyX-Code

\lang english
[(list '- l r) (- (eval l) (eval r))]
\end_layout

\begin_layout LyX-Code

\lang english
[else (error 'eval "bad syntax in ~s" expr)]
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
))
\end_layout

\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
ואמרנו שהקוד הזה עובד נהדר, אבל יש לו בעיה שה
\begin_inset Formula $syntax$
\end_inset

 וה 
\begin_inset Formula $semantics$
\end_inset

 מעורבים זה בזה , ואנחו רוצים להפריד, שיהיה חלק שיעשה 
\begin_inset Formula $parsing$
\end_inset

 וחלק שיעשה את ה 
\begin_inset Formula $evaluator$
\end_inset

 , והסברנו בשיעור שעבר למה אנחנו מעוניינים בחלוקה הזו
\end_layout

\begin_layout Standard
במילים אחרות, נרצה שהטסטים הבאים יעברו:
\end_layout

\begin_layout LyX-Code

\lang english
(test (eval (parse "3"))             => 3)   
\end_layout

\begin_layout LyX-Code

\lang english
(test (eval (parse "{+ 3 4}"))       => 7)   
\end_layout

\begin_layout LyX-Code

\lang english
(test (eval (parse "{+ {- 3 4} 7}")) => 6) 
\end_layout

\begin_layout Standard
כלומר פונקציה 
\begin_inset Formula $parse$
\end_inset

 שעוברת על הביטוי סינטקטית ומאשרת אותו, ואת הביטוי הזו הפונקציה 
\begin_inset Formula $eval$
\end_inset

 מעריכה ומחשבת.
 
\end_layout

\begin_layout Standard
נכתוב את כל הקוד מהתחלה:
\end_layout

\begin_layout LyX-Code
\align left

\lang english
#lang pl
\end_layout

\begin_layout LyX-Code

\lang english
(define-type AE
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[Num Number]
\end_layout

\begin_layout LyX-Code

\lang english
[Add AE AE]
\end_layout

\begin_layout LyX-Code

\lang english
[Sub AE AE])
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(: parse : String -> AE) 
\end_layout

\begin_layout LyX-Code

\lang english
(define (parse code)   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(parse-sexpr (string->sexpr code)))
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(: parse-sexpr : Sexpr -> AE)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (parse-sexpr sexpr)        
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(match sexpr     
\end_layout

\begin_layout LyX-Code

\lang english
[(number: n ) (Num n)]     
\end_layout

\begin_layout LyX-Code

\lang english
[(list '+ l r) (Add (parse-sexpr l) (parse-sexpr r))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(list '- l r) (Sub (parse-sexpr l) (parse-sexpr r))]))
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\lang english
(: eval : AE -> Number) (define (eval expr)   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(cases expr     [(Num n) n]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Add l r) (+ (eval l) (eval r))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Sub l r) (- (eval l) (eval r))]))
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(: run : String -> Number) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (run code)   
\end_layout

\begin_layout LyX-Code

\lang english
(eval (parse code)))
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(test (run "3") => 3) 
\end_layout

\begin_layout LyX-Code

\lang english
(test (run "{ + 3 4 }") => 7) 
\end_layout

\begin_layout LyX-Code

\lang english
(test (run "{ - { + 3 4 } 6 }") => 1)
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
שאלה האם מתקיימת תכונת ה 
\begin_inset Formula $\text{Compositionality }$
\end_inset

?
\end_layout

\begin_layout Standard
כן, בגלל ש:
\end_layout

\begin_layout Itemize
במקרי הבסיס אנחנו נותנים מיידית, ערך ל'עלה'
\end_layout

\begin_layout Itemize
במקרי הריקורסיה אנחנו מבצעים חיבור/חיסור בין טיפוסים שקיבלנו
\end_layout

\begin_layout Standard
נעיר שבשפות תכנות תמיד נרצה את התכונה 
\begin_inset Formula $\text{Compositionality }$
\end_inset

 , אבל לעולם לא נצליח להשיג במלואה, כיון שיש לנו 
\bar under
שמות מזהים
\bar default
 
\bar under
)=משתנים(
\bar default
 והערך של משתנה מצריך מאיתנו את ה
\begin_inset Quotes erd
\end_inset

תמונה הגדולה
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\align left

\series bold
שיעור 
\numeric on
5
\numeric off
 
\end_layout

\begin_layout Standard
בשיעור שעבר פיתחנו שפה, שעובדת ורצה.
 מספר הערות:
\end_layout

\begin_layout Itemize
ניקח לדוגמה את הביטוי : 
\begin_inset Formula $\text{"\{* \{+ 2 4\}\{+ 2 4\}\}}"$
\end_inset

 הסוגריים המסולסות 
\begin_inset Quotes eld
\end_inset

נעלמות
\begin_inset Quotes erd
\end_inset

 כאשר אנחנו מפעילים את הפונקציה 
\begin_inset Formula $\text{string->sexpr }$
\end_inset

שיוצרת לנו את הרישמה: 
\begin_inset Formula $\text{( * ( + 2 4 ) ( + 2 4))}$
\end_inset


\end_layout

\begin_layout Itemize
נשים לב לכפילות של 
\begin_inset Formula $\text{" \{ + 2 4 \}}"$
\end_inset

 ונרצה לצור שמות-מזהים )=משתנים( כלומר היינו רוצים 
\begin_inset Formula $\text{x = \{+ 2 4 \}}$
\end_inset

, למה? 
\end_layout

\begin_deeper
\begin_layout Itemize
קוד קריא יותר
\end_layout

\begin_layout Itemize
יעילות - )לחשב פעם אחת(
\end_layout

\begin_layout Itemize
להמנע משכפול קוד: קל לתחזק ומונע באגים
\end_layout

\begin_layout Itemize
כח ביטוי למתכנת, למשל הביטוי
\begin_inset Formula $\text{\{ * salary salary\}}$
\end_inset

 נותן את האפשרות להבין:
\end_layout

\begin_deeper
\begin_layout Itemize
שדווקא לקחתי את אותו ערך
\end_layout

\begin_layout Itemize
שהערך קשור לעולם המשכורות
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsubsection
\begin_inset Formula $WAE$
\end_inset

 ו 
\begin_inset Formula $With$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Let$
\end_inset

 : נזכיר את המבנה של 
\begin_inset Formula $let$
\end_inset

 ב 
\begin_inset Formula $reacket$
\end_inset

 : 
\begin_inset Formula $\text{(let ([x (+ 4 2) (* x x))}$
\end_inset

.
\end_layout

\begin_layout Standard
נרצה לצור משהו דומה אצלנו, נבחר את המילה 
\begin_inset Formula $with$
\end_inset

 , ונרצה לאפשר זאת בשפה שלנו.
 לכן:
\end_layout

\begin_layout Itemize
נשפר את מבנה הנתונים, ונקרא לו 
\begin_inset Formula $WAE$
\end_inset

 
\end_layout

\begin_layout Itemize
ונגדיר שאנחנו רוצים שיתקיים:
\end_layout

\begin_layout LyX-Code

\lang english
<WAE> ::= 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
<num>
\end_layout

\begin_layout LyX-Code

\lang english
| { + <WAE> <WAE> }
\end_layout

\begin_layout LyX-Code

\lang english
| { - <WAE> <WAE> }
\end_layout

\begin_layout LyX-Code

\lang english
| { * <WAE> <WAE> }
\end_layout

\begin_layout LyX-Code

\lang english
| { / <WAE> <WAE> }
\end_layout

\begin_layout LyX-Code

\lang english
| { with { <id> <WAE> } <WAE> }  ;;; {with {name named-expression } body
 }       
\end_layout

\begin_layout LyX-Code

\lang english
| <id> 
\end_layout

\end_deeper
\begin_layout Itemize

\lang english
while : 
\end_layout

\begin_deeper
\begin_layout Itemize

\lang english
<num> : identifies any expression that pl evaluates to a Number
\end_layout

\begin_layout Itemize

\lang english
<id> : : identifies any expression that pl evaluates to a Symbol
\end_layout

\end_deeper
\begin_layout Itemize
הערה : מבחינה תחברית ביטוי כמו 
\begin_inset Formula $"x","y"$
\end_inset

 הוא תקין , כי כעת יש את הכלל 
\begin_inset Formula $\text{<WEA>\ensuremath{\rightarrow} <id>}$
\end_inset

 אבל מבחינת סמנטית הם לא )במקרה ורשמנו רק 
\begin_inset Formula $"x"$
\end_inset

 ללא הצהרה.
\end_layout

\begin_layout Itemize
נרצה שהמתשמש ידע אם עשה טעות רגילה או טעות שקשורה ל 
\begin_inset Formula $with$
\end_inset

 , ולכן נפריד למקרים.
\end_layout

\begin_layout LyX-Code

\lang english
(define-type WAE   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[Num Number]   
\end_layout

\begin_layout LyX-Code

\lang english
[Add WAE WAE]   
\end_layout

\begin_layout LyX-Code

\lang english
[Sub WAE WAE]   
\end_layout

\begin_layout LyX-Code

\lang english
[Mul WAE WAE]   
\end_layout

\begin_layout LyX-Code

\lang english
[Div WAE WAE]   
\end_layout

\begin_layout LyX-Code

\lang english
[Id Symbol]   
\end_layout

\begin_layout LyX-Code

\lang english
[With Symbol WAE WAE])
\end_layout

\begin_layout LyX-Code

\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(: parse : String -> WAE) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (parse code)   
\end_layout

\begin_layout LyX-Code

\lang english
(parse-sexpr (string->sexpr code)))
\end_layout

\begin_layout LyX-Code

\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(: parse-sexpr : Sexpr -> WAE)    
\end_layout

\begin_layout LyX-Code

\lang english
(define (parse-sexpr sexpr)        
\end_layout

\begin_layout LyX-Code

\lang english
(match sexpr     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(number: n ) (Num n)]      
\end_layout

\begin_layout LyX-Code

\lang english
[(symbol: name) (Id name)]     
\end_layout

\begin_layout LyX-Code

\lang english
[(list '+ l r) (Add (parse-sexpr l) (parse-sexpr r))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(list '- l r) (Sub (parse-sexpr l) (parse-sexpr r))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(list '* l r) (Mul (parse-sexpr l) (parse-sexpr r))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(list '/ l r) (Div (parse-sexpr l) (parse-sexpr r))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(cons 'with _ )       
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(match sexpr         
\end_layout

\begin_layout LyX-Code

\lang english
[(list 'with (list (symbol: name) named-expr) body) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(With name (parse-sexpr named-expr) (parse-sexpr body))]         
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
[else (error 'parse-sexpr "bad 'with' syntax in ~s" sexpr)])]     
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
[else (error 'parse-sexpr "bad syntax in ~s" sexpr)]))
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(test (parse "5") => (Num 5)) 
\end_layout

\begin_layout LyX-Code

\lang english
(test (parse "{ + 3 4 }") => (Add (Num 3) (Num 4))) 
\end_layout

\begin_layout LyX-Code

\lang english
(test (parse "x") => (Id 'x)) (test (parse "{ + 4 2 }") => (Add (Num 4)
 (Num 2))) 
\end_layout

\begin_layout LyX-Code

\lang english
(test (parse "{ * x x }") => (Mul (Id 'x) (Id 'x)))
\end_layout

\begin_layout LyX-Code

\lang english
(test (parse " { with {x { + 4 2 }} {* x x }}") => (With 'x(Add (Num 4)
 (Num 2))                                       (Mul (Id 'x) (Id 'x))))
\end_layout

\begin_layout LyX-Code

\lang english
(test (parse "{ with x {+ 4 2 } {* x x }}") =error> "bad 'with'") 
\end_layout

\begin_layout Itemize
\begin_inset Formula $eval$
\end_inset

 ל 
\begin_inset Formula $with$
\end_inset

 , מצריך את השלבים הבאים:
\end_layout

\begin_deeper
\begin_layout Enumerate
הערך את 
\begin_inset Formula $\text{name-expr }$
\end_inset

 וקבל ערך 
\begin_inset Formula $v$
\end_inset

 
\end_layout

\begin_layout Enumerate
החלף את המופעים המתאימים של 
\begin_inset Formula $name$
\end_inset

 בערך 
\begin_inset Formula $v$
\end_inset

 בתוך 
\begin_inset Formula $body$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
הסינטקס: 
\begin_inset Formula $\text{[name/v]body}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
הערך את 
\begin_inset Formula $body$
\end_inset

 
\end_layout

\begin_layout Itemize
בדוגמה שלנו תחשב 
\begin_inset Formula $eval\left(\text{+ 4 2}\right)$
\end_inset

 תכניס את 
\begin_inset Formula $x\leftarrow6$
\end_inset

 , ותבצע 
\begin_inset Formula $\left\{ \text{* 6 6}\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
לכן צריך לדעת לעשות החלפה 
\begin_inset Formula $Subst=$
\end_inset

 .
 ננסה להגדיר פורמלית את 
\begin_inset Formula $\left[x/v\right]e$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\bar under
נסיון 
\numeric on
1
\numeric off
:
\bar default
 החלף את כל המופעים של 
\begin_inset Formula $x$
\end_inset

 בערך 
\begin_inset Formula $v$
\end_inset

 :
\begin_inset Formula 
\[
\begin{matrix}\text{\{with \{\ensuremath{\overbrace{x}^{x}} \overbrace{x}^{v} \}\ensuremath{\overbrace{\text{\{+ x x\}}}^{e}}}\Rightarrow\text{\{+ 5 5\}}\checkmark\\
\\
\text{\{with \{x 5 \}\ensuremath{\text{\{+ 10 4\}}}}\Rightarrow\text{\{+ 10 4\} }\checkmark
\end{matrix}
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
הבעיה:
\begin_inset Formula 
\[
\begin{matrix}\text{\{with \{x 5 \}\ensuremath{\text{\{+x \{with \{ x 3\} 8 \}}}}\Rightarrow\text{\{\ensuremath{\text{\{+ 5 \{with \{ 5 3\} 8 \}}}\textbf{bad syntax}}\end{matrix}
\]

\end_inset


\end_layout

\begin_layout Standard
ובשביל לפתור אותו נגדיר מושגים חדשים, שמטרתם להבדיל בין ה
\begin_inset Formula $x$
\end_inset

 הפנימי לחיצוני:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\text{Binding instance}$
\end_inset

 - מופע של 
\begin_inset Formula $x$
\end_inset

 , שבו אני מקשר את 
\begin_inset Formula $x$
\end_inset

 לביטוי כלשהו ) הצהרה על שם מזהה 
\begin_inset Formula $x$
\end_inset

 (
\end_layout

\begin_layout Itemize
\begin_inset Formula $\text{Scope }$
\end_inset

 - עבור 
\begin_inset Formula $\text{Binding instance}$
\end_inset

 אותו חלק בקוד שבו כל מופע של 
\begin_inset Formula $x$
\end_inset

 מקושר למופע ההצהרתי הזה
\end_layout

\begin_layout Itemize
\begin_inset Formula $\text{Bound instance}$
\end_inset

 - כל מופע של 
\begin_inset Formula $x$
\end_inset

 שאינו 
\begin_inset Formula $\text{Binding instance }$
\end_inset

 וגם נמצא בתוך 
\begin_inset Formula $with$
\end_inset

של 
\begin_inset Formula $\text{Binding instance }$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\text{Free instance }$
\end_inset

 - כל מופע של 
\begin_inset Formula $x$
\end_inset

 שאינו 
\begin_inset Formula $\text{Binding instance }$
\end_inset

 וגם אינו 
\begin_inset Formula $\text{Bound}$
\end_inset


\end_layout

\begin_layout Standard
לדוגמה:
\begin_inset Formula 
\[
\begin{matrix}\text{e =\{with \{\ensuremath{\underbrace{x}_{\text{\ensuremath{\begin{matrix}Binding\end{matrix}}}}} 5 \}\ensuremath{\text{\{+x \{with \{ \ensuremath{\underbrace{\text{ x x }}_{Bound}}\}\} }}}\end{matrix}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\bar under
נסיון שני: 
\bar default
החלף את כל המופעים של 
\begin_inset Formula $x$
\end_inset

 בתוך 
\begin_inset Formula $e$
\end_inset

 שאינם 
\begin_inset Formula $binding$
\end_inset

 בערך 
\begin_inset Formula $v$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{matrix}\text{\{with \{x 5 \}\ensuremath{\text{\ensuremath{\overbrace{\text{\{+x \{with \{ x 3\} \textbf{10} \}}}^{e}}\}}}}\Rightarrow\text{\{\ensuremath{\text{\{+ 5 \{with \{ x 3\} 10 \}}}\ensuremath{\checkmark}}\\
\\
\text{\{with \{x 5 \}\ensuremath{\text{\ensuremath{\overbrace{\text{\{+x \{with \{ x 3\} \textbf{x} \}}}^{e}}\}}}}\Rightarrow\text{\{\ensuremath{\text{\{+ 5 \{with \{ x 3\} \textbf{5} \}}}\ensuremath{\chi\text{ \textbf{x should be 3}}}}\\
\\
\end{matrix}
\]

\end_inset


\end_layout

\begin_layout Itemize

\bar under
נסיון שלישי: 
\bar default
החלף את כל המופעים של 
\begin_inset Formula $x$
\end_inset

 בתוך 
\begin_inset Formula $e$
\end_inset

 שאינם 
\begin_inset Formula $binding$
\end_inset

 וגם אינם בתוך ה 
\begin_inset Formula $scope$
\end_inset

 של מזהה עם אותו שם.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{matrix}\text{\{with \{x 5 \}\text{\{+ x x\}}\}}\Rightarrow\text{\{+ 5 5 \} \ensuremath{\checkmark}}\\
\\
\text{\{with \{x 5 \}\ensuremath{\text{\ensuremath{\overbrace{\text{\{+x \{with \{ x 3\} \textbf{x} \}}}^{e}}\}}}}\Rightarrow\text{\{\ensuremath{\text{\{+ 5 \{with \{ x 3\} x \}}}\ensuremath{\checkmark}}\\
\text{\{with \{x 5 \}\ensuremath{\text{\ensuremath{\overbrace{\text{\{+x \{with \{ y 3\} \textbf{x} \}}}^{e}}\}}}}\Rightarrow\text{\{\ensuremath{\text{\{+ 5 \{with \{ y 3\} 5 \}}}\ensuremath{\checkmark}}
\end{matrix}
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
לסיכום: 
\begin_inset Formula $[x/v]e$
\end_inset

 - החלף את כל המופעים החופשיים של 
\begin_inset Formula $x$
\end_inset

 בתוך 
\begin_inset Formula $e$
\end_inset

 
\end_layout

\begin_layout Itemize
שיעור הבא נשלים את קטע הקוד החסר
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\align left

\series bold
שיעור 
\numeric on
6
\numeric off
 
\end_layout

\begin_layout Standard
חזרה על 
\begin_inset Formula $with$
\end_inset

 - בשיעור שעבר דיברנו על ה 
\begin_inset Formula $parsing$
\end_inset

 וכעת נרצה לבצע לו 
\begin_inset Formula $eval$
\end_inset

 , נזכיר את השלבים:
\end_layout

\begin_layout Enumerate

\lang english
val 
\begin_inset Formula $\leftarrow$
\end_inset

 (eval named-expr)
\end_layout

\begin_layout Enumerate

\lang english
subst body name 
\series bold
val 
\begin_inset Formula $\equiv\left[name/val\right]body\equiv\left[x/v\right]e$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
הגדרנו 
\begin_inset Formula $\left[x/v\right]e$
\end_inset

 : החלף את כל 
\bar under
המופעים החופשיים
\bar default
 של 
\begin_inset Formula $x$
\end_inset

 בתוך 
\begin_inset Formula $e$
\end_inset

 בערך 
\begin_inset Formula $v$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\lang english
eval body
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
נזכיר גם את המושגים: 
\begin_inset Formula $binding-instance\left(green\right),free\left(purple\right)/bound\left(red\right)$
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename prog-lang-picture/less06_01.png
	lyxscale 70
	scale 60

\end_inset


\end_layout

\begin_layout Standard
היום:
\end_layout

\begin_layout Enumerate
נכתוב פרוצדורה 
\begin_inset Formula $subst$
\end_inset

 - עושה פעולת תחבירית.
 מקבלת ערך חדש שם ביטוי, מחליפה את כל המופעים החופשיים של שם בתוך ביטוי
 בערך החדש.
\end_layout

\begin_layout Enumerate
נכתוב את 
\begin_inset Formula $eval$
\end_inset

 )מחשב( בעזרת 
\begin_inset Formula $subst$
\end_inset

 
\end_layout

\begin_layout Standard
לדוגמה הביטוי:
\end_layout

\begin_layout LyX-Code
\align left

\lang english
(eval ( with 
\begin_inset Formula $\underbrace{'x}_{from}$
\end_inset

 add (Num 2) (Num 3))
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(Mul (Id 'x) (Id 'x)))) // := body
\end_layout

\end_deeper
\begin_layout LyX-Code

\bar under
\lang english
steps:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
1.
 eval (Add (Num 2) (Num 3)) // := to
\end_layout

\begin_layout LyX-Code

\lang english
2.
 subst := body from to 
\begin_inset Formula $\rightarrow$
\end_inset

  
\end_layout

\begin_layout LyX-Code

\lang english
3.
 eval (Mul (Num 5 ) (Num 5))
\end_layout

\end_deeper
\begin_layout Standard
הערות:
\end_layout

\begin_layout Enumerate
נשים לב שבמקרה של 
\begin_inset Formula $Id$
\end_inset

 מראש לא נקבל משתנה חופשי כי נמנע מהריקורסיה להכנס למקרה הזה ב 
\begin_inset Formula $\boldsymbol{With}$
\end_inset

 
\end_layout

\begin_layout Enumerate
נשים לב שב
\begin_inset Formula $test$
\end_inset

 הבא:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(test (subst 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(With 
\series bold
\bar under
'x
\series default
\bar default
 ;; name
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(Num 3) ;; name-expr                    
\end_layout

\begin_layout LyX-Code

\lang english
(Add (Id 'x) (Num 5 ))) ;;body .
 note: 
\bar under
'
\series bold
x is not free var
\series default
\bar default
             
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
'x ;; from              
\end_layout

\begin_layout LyX-Code

\lang english
(Num 8)) ;; to       
\end_layout

\begin_layout LyX-Code

\lang english
=> (With 'x                
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(Num 3)                
\end_layout

\begin_layout LyX-Code

\lang english
(Add 
\series bold
\bar under
(Id 'x)
\series default
\bar default
 (Num 5)))) 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
ה 
\begin_inset Formula $'x$
\end_inset

 הוא 
\series bold
לא משתנה חופשי 
\series default
ולכן נשאיר אותו כמות שהוא, לעומת זאת כאן את 
\begin_inset Formula $'x$
\end_inset

 ב 
\begin_inset Formula $\left(Num\ 8\right)$
\end_inset

 
\end_layout

\begin_layout LyX-Code

\lang english
(test (subst 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(With 'y ;; name
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(Num 3) ;; name-expr                    
\end_layout

\begin_layout LyX-Code

\lang english
(Add (Id 'x) (Num 5 ))) ;;body .
 note: 
\bar under
'
\series bold
x is bound var
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
'x ;; from              
\end_layout

\begin_layout LyX-Code

\series bold
\bar under
\lang english
(Num 8)) ;; to 
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
=> (With 
\bar under
'y
\bar default
                
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
  (Num 3)                
\end_layout

\begin_layout LyX-Code

\lang english
  (Add 
\series bold
\bar under
(Num  8)
\series default
\bar default
 (Num 5)))) 
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
נשים לב שגם את 
\begin_inset Formula $named-expr$
\end_inset

 צריך לשלוח ל
\begin_inset Formula $subst$
\end_inset

 
\end_layout

\begin_layout Enumerate
אם 
\begin_inset Formula $name=from$
\end_inset

 נרצה להחזיר את ה 
\begin_inset Formula $body$
\end_inset

 כמו שהוא בלי החלפה
\end_layout

\begin_layout Standard
בסה
\begin_inset Quotes erd
\end_inset

כ:
\end_layout

\begin_layout LyX-Code

\lang english
(: subst : WAE Symbol WAE -> WAE ) 
\end_layout

\begin_layout LyX-Code

\lang english
;; takes a WAE trre expr and a name and a value
\end_layout

\begin_layout LyX-Code

\lang english
;; and return a new tree with the same  structure 
\end_layout

\begin_layout LyX-Code

\lang english
;; but without aby free instances of name (these are replaced by value 
\end_layout

\begin_layout LyX-Code

\lang english
(define (subst expr from to)   
\end_layout

\begin_layout LyX-Code

\lang english
(cases expr     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(Num n) expr]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Add l r) (Add (subst l from to) (subst r from to))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Sub l r) (Sub (subst l from to) (subst r from to))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Mul l r) (Mul (subst l from to) (subst r from to))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Div l r) (Div (subst l from to) (subst r from to))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Id name) (if (eq? name from) to expr)]     
\end_layout

\begin_layout LyX-Code

\lang english
[(With name named-expr body)      
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(With name ; name            
\end_layout

\begin_layout LyX-Code

\lang english
(subst named-expr from to) ; substituted name-expr           
\end_layout

\begin_layout LyX-Code

\lang english
(if (eq? name from)                
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
body ; non-substituted body 
\end_layout

\begin_layout LyX-Code

\lang english
(subst body from to)))])) ;; substituted 
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
כעת נכתוב את 
\begin_inset Formula $eval$
\end_inset

 לפי השלבים שהזכרנו בתחילת השיעור:
\end_layout

\begin_layout LyX-Code

\lang english
#| How to evaluate (With name named-expr body) 
\end_layout

\begin_layout LyX-Code

\lang english
1.
 v <- (eval named-expr) 
\end_layout

\begin_layout LyX-Code

\lang english
2.
 body <- (subst body name v) 
\end_layout

\begin_layout LyX-Code

\lang english
3.
 (eval body) 
\end_layout

\begin_layout LyX-Code

\lang english
|#
\end_layout

\begin_layout LyX-Code

\lang english
(: eval : WAE -> Number) 
\end_layout

\begin_layout LyX-Code

\lang english
(define (eval expr)   
\end_layout

\begin_layout LyX-Code

\lang english
(cases expr     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(Num n) n]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Add l r) (+ (eval l) (eval r))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Sub l r) (- (eval l) (eval r))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Mul l r) (* (eval l) (eval r))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Div l r) (/ (eval l) (eval r))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Id name) (error 'eval "free identifier ~s" name)]     
\end_layout

\begin_layout LyX-Code

\lang english
[(With name named-expr body)      
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(eval (subst body name (Num (eval named-expr))))]))
\end_layout

\begin_layout LyX-Code

\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\lang english
(: run : String -> Number) 
\end_layout

\begin_layout LyX-Code

\lang english
(define (run code)   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(eval (parse code)))
\end_layout

\begin_layout LyX-Code

\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
;;----------------- tests --------------------
\end_layout

\begin_layout LyX-Code

\lang english
(test (run "5") => 5) 
\end_layout

\begin_layout LyX-Code

\lang english
(test (run "z") =error> "free ") 
\end_layout

\begin_layout LyX-Code

\lang english
(test (run "{+ 5 5}") => 10) 
\end_layout

\begin_layout LyX-Code

\lang english
(test (run "{with {x {+ 5 5}} {+ x x}}") => 20) 
\end_layout

\begin_layout LyX-Code

\lang english
(test (run "{with {x 5} {+ x x}}") => 10)
\end_layout

\begin_layout LyX-Code

\lang english
(test (run "{with {x {+ 5 5}}               
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {y {- x 3}}                 
\end_layout

\begin_layout LyX-Code

\lang english
{+ x y}}}") => 17)
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(test (run "{with {x 5}               
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{+ x {with {x 3} 10}}}") => 15)
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(test (run "{with {x 5}              
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{+ x {with {x 3} {+ x x}}}}") => 11)
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(test (run "{with {x {+ 3 4}} {+ x {with {y 3} x}}}") => 14)
\end_layout

\begin_layout LyX-Code

\lang english
(test (run "{with {x 5}                
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {y {* x 3}}                
\end_layout

\begin_layout LyX-Code

\lang english
{- y x}}}") => 10)
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(test (run "{with {x 8}               
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {x {* x x}}                  
\end_layout

\begin_layout LyX-Code

\lang english
{/ x 4}}}") => 16)
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(test (run "{with {x 1} y}") =error> "free identifier") 
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\align left

\series bold
שיעור 
\numeric on
7
\numeric off
 
\end_layout

\begin_layout Subsubsection
\begin_inset Formula $FLANG$
\end_inset

 ופונקציות
\end_layout

\begin_layout Standard
תזכורת: בשיעור שעבר בנינו 
\begin_inset Formula $interpeter$
\end_inset

 שיודע לחשב ביטויים ארימתטים, נרצה היום לשפר אותו:
\end_layout

\begin_layout Enumerate
נרצה לפתח מנגנון שיודע להגדיר פונקציה אנונומית
\end_layout

\begin_deeper
\begin_layout Itemize
לכן נניח והגדרנו את:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{fun {x}
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{* x x}}
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Enumerate
נרצה לפתח מנגנון לקריאה 
\begin_inset Formula $\left(call\right)$
\end_inset

 של לפונקציה = איך נפעיל אותה?
\end_layout

\begin_deeper
\begin_layout Itemize
נשתמש בתבנית הרגילה.
 לדוגמה תהיה פונקציה 
\begin_inset Formula $f$
\end_inset

 כלשהי אז ב 
\begin_inset Formula $Racket$
\end_inset

 נפעיל אותה כך:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(f 5)
\end_layout

\end_deeper
\begin_layout Itemize
אילו רצו להיות מפורשים יותר היו מוסיפים 
\begin_inset Formula $call$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(call f 5)
\end_layout

\begin_layout Itemize
אצלנו:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call f 5}
\end_layout

\begin_layout LyX-Code

\lang english
{call {fun {x}
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{* x x}} 5}
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize
נשים לב שהצורה הזו לא 
\begin_inset Quotes eld
\end_inset

נוחה
\begin_inset Quotes erd
\end_inset

, וגם לא נותנת לנו את הכח של הפונקציות , ולכן נרצה להגדיר פונקציה ולהשתמש
 בה שוב ושב
\end_layout

\begin_deeper
\begin_layout Itemize
הערה: להגדיר פונקציה נותן לי את האפשרות לשמור את אופן הפעולה )את ה'איך'(
 , ולחזור עליה שוב ושב :
\end_layout

\begin_layout LyX-Code

\lang english
{with {sqr {fun {x}
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
  {* x x}}}
\end_layout

\begin_layout LyX-Code

\lang english
{+ {call sqr 5 }}
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call sqr 6 }}
\end_layout

\end_deeper
\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
ישנן
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
3
\family roman
\series medium
\shape up
\size normal
\emph off
\numeric off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
גישות לסוגי הפונקציות:
\end_layout

\begin_layout Enumerate
בעבר פוקציות היו אובייקטים שיודעים לבצע 
\begin_inset Quotes eld
\end_inset

חישוב
\begin_inset Quotes erd
\end_inset

 על נתונים מסוים 
\begin_inset Formula $\left(\text{first order}\right)$
\end_inset


\end_layout

\begin_layout Enumerate
כיום מבינים שזהו אובייקט הרבה יותר מורכב, וניתן להביע איתו חישובים ותהליכים
 ברמה יותר גבוהה
\begin_inset Formula $\left(\text{high order }\right)$
\end_inset

 , ויותר קריאה.
\end_layout

\begin_deeper
\begin_layout Enumerate
ומכאן מגיעות האפשרויות של שליחת וקבלה פונקציה כמשתנה
\end_layout

\end_deeper
\begin_layout Enumerate
שפות בהן פונקציה היא טיפוס כמו כל טיפוס אחר 
\begin_inset Formula $\left(\text{First class}\right)$
\end_inset

 
\begin_inset Formula $\Leftarrow$
\end_inset

 נותן לנו את האפשרות לפונקציה ללא שם )אנונימית(
\end_layout

\begin_deeper
\begin_layout Enumerate
מאפשר להגדיר פונקציה בזמן ריצה
\end_layout

\begin_layout Enumerate
יכולות להשמר במבנה נתונים, ועוד.
\end_layout

\end_deeper
\begin_layout Standard
נדגים את היתרון בשפה עילית: להלן קוד בשפה תחתית 
\begin_inset Formula $\left(\text{first order }\right)$
\end_inset

 , מה הוא מבצע?
\end_layout

\begin_layout LyX-Code

\lang english
x = b * b
\end_layout

\begin_layout LyX-Code

\lang english
y = 4 * a 
\end_layout

\begin_layout LyX-Code

\lang english
y = y * c 
\end_layout

\begin_layout LyX-Code

\lang english
x = x – y 
\end_layout

\begin_layout LyX-Code

\lang english
x = sqrt(x) 
\end_layout

\begin_layout LyX-Code

\lang english
y = -b 
\end_layout

\begin_layout LyX-Code

\lang english
x = y + x 
\end_layout

\begin_layout LyX-Code

\lang english
y = 2 * a 
\end_layout

\begin_layout LyX-Code

\lang english
s = x / y 
\end_layout

\begin_layout Standard
תשובה, קשה לומר.
 לעומת זאת קוד בשפה עילית 
\begin_inset Formula $\left(\text{First class }\right)$
\end_inset

 :
\end_layout

\begin_layout LyX-Code

\lang english
(-b + sqrt(b^2 - 4*a*c)) / 2a 
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

מספר
\begin_inset Quotes erd
\end_inset

 לנו שזה פתרון למשוואה ריבועית, ובכך הרווחנו יכולת הבעה.
 הרעיון מאחורי זה שפונקציה היא טיפוס בפני עצמו, ולא צריך הגדרה )כמו ש
\numeric on
5
\family roman
\series medium
\shape up
\size normal
\emph off
\numeric off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
לא צריך הגדרה(
\end_layout

\begin_layout Standard
דוגמה נוספת מ
\begin_inset Formula $js$
\end_inset

 :
\end_layout

\begin_layout LyX-Code

\lang english
function foo(x) {     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
function bar(y) { return x + y; }     
\end_layout

\begin_layout LyX-Code

\lang english
return bar;   
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
}   
\end_layout

\begin_layout LyX-Code

\lang english
function main() {     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
var f = foo(1);     
\end_layout

\begin_layout LyX-Code

\lang english
var g = foo(10);     
\end_layout

\begin_layout LyX-Code

\lang english
alert(">> "+ f(2) + ", " + g(2));   
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
}
\end_layout

\begin_layout Standard
בתוכנית שלנו, יש
\end_layout

\begin_layout Itemize
פעולות רגילות 
\begin_inset Formula $+,-$
\end_inset

 
\end_layout

\begin_layout Itemize
פונקציות:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $main$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $foo$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Standard
נרצה לחשוב על הפונקציות כענן , כלומר משהו שאנחנו לא מחשבים כרגע, ויום אחד
 נשתמש בו.
 
\end_layout

\begin_layout Standard
הענן הוא קופסה סגורה שיודעת לקבל פרמטר, ויש לה גוף )פעולות החישוב שלה(
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename prog-lang-picture/less07_01.png
	lyxscale 70
	scale 60

\end_inset


\end_layout

\begin_layout Standard

\bar under
נרוץ עם התכנית:
\end_layout

\begin_layout Itemize
קריאה ל 
\begin_inset Formula $main$
\end_inset

 - ללא פרמטר
\end_layout

\begin_layout Itemize
קריאה ל
\begin_inset Formula $foo$
\end_inset

 עם פרמטר 
\begin_inset Formula $x=1$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
גוף : 
\begin_inset Formula $bar$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize
קריאה ל
\begin_inset Formula $bar$
\end_inset

 : עם פרמטר 
\begin_inset Formula $y$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
גוף 
\begin_inset Formula $\text{return x+y=1+y}$
\end_inset

 כי 
\begin_inset Formula $x$
\end_inset

 משתנה חופשי
\end_layout

\end_deeper
\begin_layout Itemize
ולכן 
\begin_inset Formula $f=y+1$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename prog-lang-picture/less07_03.png
	scale 60

\end_inset


\begin_inset Graphics
	filename prog-lang-picture/less07_02.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
כנ
\begin_inset Quotes erd
\end_inset

ל ל 
\begin_inset Formula $g$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $f(2)$
\end_inset

 )נזכר ש
\begin_inset Formula $f$
\end_inset

 
\series bold
מחזיק פונקציה
\series default
( שהפרמטר שלה 
\begin_inset Formula $2$
\end_inset

 , הגוף 
\begin_inset Formula $\text{return 1+2 }$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename prog-lang-picture/less07_04.png
	scale 70

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
כנ
\begin_inset Quotes erd
\end_inset

ל ל 
\begin_inset Formula $g=10+2=12$
\end_inset

 
\end_layout

\begin_layout Itemize
סה
\begin_inset Quotes erd
\end_inset

כ: 
\begin_inset Formula $3,12$
\end_inset


\end_layout

\begin_layout Standard
לסיכום:
\end_layout

\begin_layout Itemize
בהדגמה הראינו איך הפונקציה 
\begin_inset Quotes eld
\end_inset

נוצרת בזמן ריצה
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
נתינת השם 
\begin_inset Formula $bar$
\end_inset

 לפונקציה , די מיותר והיה אפשר להשאר ללא השם
\end_layout

\begin_layout Itemize
אותו קוד ב
\begin_inset Formula $racket$
\end_inset

 :
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (foo x)     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (bar y) (+ x y)) bar) 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
נגדיר את ה 
\begin_inset Formula $BNF$
\end_inset

 שלנו - נוסיף את 
\begin_inset Formula $fun,call$
\end_inset

 
\end_layout

\begin_layout LyX-Code

\lang english
   <FLANG> ::= <num>             
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
| { + <FLANG> <FLANG> }             
\end_layout

\begin_layout LyX-Code

\lang english
| { - <FLANG> <FLANG> }             
\end_layout

\begin_layout LyX-Code

\lang english
| { * <FLANG> <FLANG> }             
\end_layout

\begin_layout LyX-Code

\lang english
| { / <FLANG> <FLANG> }             
\end_layout

\begin_layout LyX-Code

\lang english
| { with { <id> <FLANG> } <FLANG> }             
\end_layout

\begin_layout LyX-Code

\lang english
| <id>             
\end_layout

\begin_layout LyX-Code

\lang english
| { fun { <id> } <FLANG> }    // param-name         
\end_layout

\begin_layout LyX-Code

\lang english
| { call <FLANG> <FLANG> }    // fun-expr arg-expr
\end_layout

\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
נשים לב שהגדרנו ב
\begin_inset Formula $fun$
\end_inset

 את האפשרות לקריאה כזו: 
\end_layout

\begin_layout LyX-Code

\lang english
(7 6)
\end_layout

\begin_layout Standard
כלומר מספר שקיבל שם של פונקציה.
 
\series bold
אבל
\series default
 זו בעיה 
\series bold
סמנטית, 
\series default
ותחבירית זה תקין )
\begin_inset Formula $racket$
\end_inset

 עצמה אפשרו זאת, ב
\begin_inset Formula $pl$
\end_inset

 חסמו(
\end_layout

\begin_layout Standard
הקוד ל
\begin_inset Formula $parse$
\end_inset

 :
\end_layout

\begin_layout LyX-Code

\lang english
(define-type FLANG   [Num Number]   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[Add FLANG FLANG]   
\end_layout

\begin_layout LyX-Code

\lang english
[Sub FLANG FLANG]   
\end_layout

\begin_layout LyX-Code

\lang english
[Mul FLANG FLANG]   
\end_layout

\begin_layout LyX-Code

\lang english
[Div FLANG FLANG]   
\end_layout

\begin_layout LyX-Code

\lang english
[Id Symbol]   
\end_layout

\begin_layout LyX-Code

\lang english
[With Symbol FLANG FLANG]   
\end_layout

\begin_layout LyX-Code

\lang english
[Fun Symbol FLANG]   
\end_layout

\begin_layout LyX-Code

\lang english
[Call FLANG FLANG] )   
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(: parse : String -> FLANG) 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (parse code)   
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(parse-sexpr (string->sexpr code)))
\end_layout

\begin_layout LyX-Code

\lang english
(: parse-sexpr : Sexpr -> FLANG)     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (parse-sexpr sexpr)        
\end_layout

\begin_layout LyX-Code

\lang english
(match sexpr     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(number: n ) (Num n)]      
\end_layout

\begin_layout LyX-Code

\lang english
[(symbol: name) (Id name)]         
\end_layout

\begin_layout LyX-Code

\lang english
[(cons 'with _ )       
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(match sexpr         
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(list 'with (list (symbol: name) named-expr) body)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(With name (parse-sexpr named-expr) (parse-sexpr body))]     
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
[else (error 'parse-sexpr "bad 'with' syntax in ~s" sexpr)])]
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\lang english
[(cons 'fun more)        
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(match sexpr          
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(list 'fun (list (symbol: name)) body)           
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(Fun name (parse-sexpr body))]          
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
[else (error 'parse-sexpr "bad `fun' syntax in ~s" sexpr)])]
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\lang english
[(list '+ l r) (Add (parse-sexpr l) (parse-sexpr r))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(list '- l r) (Sub (parse-sexpr l) (parse-sexpr r))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(list '* l r) (Mul (parse-sexpr l) (parse-sexpr r))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(list '/ l r) (Div (parse-sexpr l) (parse-sexpr r))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(list 'call fun arg) (Call (parse-sexpr fun) (parse-sexpr arg))]     
\end_layout

\begin_layout LyX-Code

\lang english
[else (error 'parse-sexpr "bad syntax in ~s" sexpr)]     
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
)) 
\end_layout

\end_deeper
\begin_layout Standard
\align left

\series bold
שיעור 
\numeric on
8
\numeric off
 
\end_layout

\begin_layout Standard
בשיעור שעבר , הגדרנו פונקציות וממשנו את החלק של ה 
\begin_inset Formula $parse$
\end_inset

 
\end_layout

\begin_layout Standard
היום נרצה לממש את 
\begin_inset Formula $eval$
\end_inset


\end_layout

\begin_layout Standard
נתחיל מדוגמאות :
\end_layout

\begin_layout Itemize
דוגמה בסיסית - לביטוי:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{ fun {x} {+ x 1}}
\end_layout

\begin_layout Itemize
נרצה שיוחזר משהו בסגנון:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[param: 'x
\end_layout

\begin_layout LyX-Code

\lang english
body: (Add (Id 'x) (Num 1))]
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
דוגמה נוספת:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{ with { x 1 }
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{fun {y} {+x y}}}
\end_layout

\end_deeper
\begin_layout Itemize
אז מכיון ש 
\begin_inset Formula $x=1$
\end_inset

 )משתנה( נקבל:
\end_layout

\begin_layout LyX-Code

\lang english
[param: 'y
\end_layout

\begin_layout LyX-Code

\lang english
body: (Add (Num 1) (Id 'y))]
\end_layout

\end_deeper
\begin_layout Subsection
\begin_inset Formula $subst$
\end_inset

 ומודל ההחלפות
\end_layout

\begin_layout Standard
לכן נרצה להגדיר באופן פורמלי את 
\begin_inset Formula $subst$
\end_inset

 שלנו
\end_layout

\begin_layout LyX-Code

\lang english
N[v/x]                = N
\end_layout

\begin_layout LyX-Code

\lang english
{+ E1 E2}[v/x]        = {+ E1[v/x] E2[v/x]}    {- E1 E2}[v/x]        = {-
 E1[v/x] E2[v/x]}
\end_layout

\begin_layout LyX-Code

\lang english
{* E1 E2}[v/x]        = {* E1[v/x] E2[v/x]}
\end_layout

\begin_layout LyX-Code

\lang english
{/ E1 E2}[v/x]        = {/ E1[v/x] E2[v/x]}
\end_layout

\begin_layout LyX-Code

\lang english
y[v/x]                = y
\end_layout

\begin_layout LyX-Code

\lang english
x[v/x]                = v
\end_layout

\begin_layout LyX-Code

\lang english
{with {y E1} E2}[v/x] = {with {y E1[v/x]} E2[v/x]}     
\end_layout

\begin_layout LyX-Code

\lang english
{with {x E1} E2}[v/x] = {with {x E1[v/x]} E2}
\end_layout

\begin_layout LyX-Code

\lang english
{call E1 E2}[v/x]     = {call E1[v/x] E2[v/x]}
\end_layout

\begin_layout LyX-Code

\lang english
{fun {y} E}[v/x]      = {fun {y} E[v/x]}
\end_layout

\begin_layout LyX-Code

\lang english
{fun {x} E}[v/x]      = {fun {x} E }
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
הערות:
\end_layout

\begin_layout Itemize
הביטוי:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{fun {y} E}[v/x]      = {fun {y} E[v/x]}
\end_layout

\begin_layout Itemize
משמעו תחליף ב 
\begin_inset Formula $E$
\end_inset

 את הכל ה
\begin_inset Formula $x$
\end_inset

 , וזה לא משפיע על הפונקציה שלנו, כי הפרמטר שלה הוא 
\begin_inset Formula $y$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize
לעומת זאת הביטוי
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{fun {x} E}[v/x]      = {fun {x} E }
\end_layout

\begin_layout Itemize
מחייב אותנו 
\series bold
לא
\series default
 להחליף כי הפונקציה כולו תלויה בערך ש
\begin_inset Formula $x$
\end_inset

 יתקבל כפרמטר, ולכן הוא לא משתנה חופשי
\end_layout

\end_deeper
\begin_layout Itemize
אבל כאשר קוראים לפונקציה:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call E1 E2}[v/x]     = {call E1[v/x] E2[v/x]}
\end_layout

\begin_layout Itemize
נרצה להחליף כי זה כבר השימוש בפונקציה
\end_layout

\end_deeper
\begin_layout Standard
קוד ל 
\begin_inset Formula $subst$
\end_inset

 :
\end_layout

\begin_layout LyX-Code

\lang english
(: subst : FLANG Symbol FLANG -> FLANG ) 
\end_layout

\begin_layout LyX-Code

\lang english
(define (subst expr from to)   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(cases expr     
\end_layout

\begin_layout LyX-Code

\lang english
[(Num n) expr]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Add l r) (Add (subst l from to) (subst r from to))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Sub l r) (Sub (subst l from to) (subst r from to))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Mul l r) (Mul (subst l from to) (subst r from to))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Div l r) (Div (subst l from to) (subst r from to))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Id name) (if (eq? name from) to expr)]     
\end_layout

\begin_layout LyX-Code

\lang english
[(With name named-expr body)      
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(With name ; name (subst named-expr from to) ; substituted name-expr
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(if (eq? name from)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
body ; non-substituted body
\end_layout

\begin_layout LyX-Code

\lang english
(subst body from to)))] ;; substituted     
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout LyX-Code

\lang english
[(Call l r) (Call (subst l from to) (subst r from to))]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Fun bound-id bound-body)      
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(if (eq? bound-id from)          
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
expr          
\end_layout

\begin_layout LyX-Code

\lang english
(Fun bound-id (subst bound-body from to)))]     
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\lang english
)) 
\end_layout

\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
כעת נעבור ל 
\begin_inset Formula $eval$
\end_inset

 :
\end_layout

\begin_layout Itemize
מטרתנו ש 
\begin_inset Formula $eval$
\end_inset

 תחזיר שני סוגים 
\begin_inset Formula $\left(types\right)$
\end_inset

 :
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $Number$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $functions$
\end_inset

 )ענן בסגנון(:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[param: Symbol
\end_layout

\begin_layout LyX-Code

\lang english
body: (AST FLANG]
\end_layout

\end_deeper
\begin_layout Itemize
דוגמאות:
\end_layout

\begin_layout LyX-Code

\lang english
(eval (Num 1))
\end_layout

\begin_layout LyX-Code

\lang english
(eval (Fun 'x (Add (Id 'x) (Num 1))))
\end_layout

\end_deeper
\begin_layout Itemize
לכן נשנה את הגדרת 
\begin_inset Formula $eval$
\end_inset

 ל 
\begin_inset Formula $FLANG$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
נציין שזהו פתרון בעייתי , כי האובייקט 
\begin_inset Formula $FLANG$
\end_inset

 לכשעצמו מכיל בנאים שלא קשורים, והוא תוצר של תהליך 
\begin_inset Formula $parse$
\end_inset

 וזה מוזר לערבב אבל בכל מקרה נבצע תיקון מעין זה בהמשך, ולכן כעת נשאר עם
 הפתרון הזה.
\end_layout

\begin_layout Itemize
נרצה שידע להתמודד עם הטסטים הבאים:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(test (eval (Num 1 )) => (Num 1)) 
\end_layout

\begin_layout LyX-Code

\lang english
(test (eval (Mul (Num 1) (Num 6))) => (Num 6)) 
\end_layout

\begin_layout LyX-Code

\lang english
(test (eval (Fun 'x (Add (Id 'x) (Num 1)))) =>
\end_layout

\begin_layout LyX-Code

\lang english
            (Fun 'x (Add (Id 'x) (Num 1))))
\end_layout

\begin_layout LyX-Code

\lang english
(test (eval (With 'y
\end_layout

\begin_layout LyX-Code

\lang english
                  (Num 5)
\end_layout

\begin_layout LyX-Code

\lang english
                  (Fun 'x (Add (Id 'x) (Num 'y))))) =>
\end_layout

\begin_layout LyX-Code

\lang english
                  (Fun 'x (Add (Id 'x) (Num 5))))
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
נגדיר פורמלית את 
\begin_inset Formula $eval$
\end_inset

 :
\end_layout

\begin_layout LyX-Code

\lang english
eval(N)         = N
\end_layout

\begin_layout LyX-Code

\lang english
eval({+ E1 E2}) = eval(E1) + eval(E2)
\end_layout

\begin_layout LyX-Code

\lang english
eval({- E1 E2}) = eval(E1) - eval(E2)
\end_layout

\begin_layout LyX-Code

\lang english
eval({* E1 E2}) = eval(E1) * eval(E2)
\end_layout

\begin_layout LyX-Code

\lang english
eval({/ E1 E2}) = eval(E1) / eval(E2)
\end_layout

\begin_layout LyX-Code

\lang english
eval(id)        = error!
\end_layout

\begin_layout LyX-Code

\lang english
eval({with {x E1} E2}) = eval(E2[eval(E1)/x])
\end_layout

\begin_layout LyX-Code

\lang english
eval(FUN)       = FUN ; assuming FUN is a function expression
\end_layout

\begin_layout LyX-Code

\lang english
eval({call E1 E2})=  if {fun {x} Ef } <--- eval (E1)
\end_layout

\begin_layout LyX-Code

\lang english
                     then  eval(Ef[x/eval(E2)])
\end_layout

\begin_layout LyX-Code

\lang english
                     else Error
\end_layout

\begin_layout LyX-Code

\lang english
eval(Ef[eval(E2)/x])   if eval(E1) = {fun {x} Ef}
\end_layout

\begin_layout LyX-Code

\lang english
                  = error!                 otherwise 
\end_layout

\begin_layout Standard
הערות:
\end_layout

\begin_layout Itemize
\begin_inset Formula $id$
\end_inset

 יתן 
\begin_inset Formula $error$
\end_inset

 , כי אין משמעות ל 
\begin_inset Formula $"x"$
\end_inset


\end_layout

\begin_layout Itemize
כפי שאמרנו 
\begin_inset Formula $Fun$
\end_inset

 נחזיר כמו שהוא, כי מחכה לפרמטר בשביל לקבל משמעות
\end_layout

\begin_layout Itemize
ב 
\begin_inset Formula $call$
\end_inset

 ב
\begin_inset Formula $if$
\end_inset

 , נרצה לחשב את 
\begin_inset Formula $eval(E2)$
\end_inset

 בשביל יעילות, שהפונקציה כבר תקבל ערך מחושב, ולא תצרך ללכת ולחשב אותו, לדוגמה:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call {Fun {x} { + x x }}}
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{* 5 { * 17 {* 2 3}}}}
\end_layout

\end_deeper
\begin_layout Itemize
אז ניתן לחשב את 
\begin_inset Formula $x$
\end_inset

 בכל פעם או מראש לחשב )וזה מה שנעדיף( ושהפונקציה תעבוד עם
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
510
\end_layout

\end_deeper
\begin_layout Itemize
נשים לב שבגלל ששינו את הערך המוחזר ל
\begin_inset Formula $FLANG$
\end_inset

 אנחנו צריכים לבצע התאמות בכל מקום שהפונקציה מחזירה מספר למשל 
\begin_inset Formula $\text{(Add (Num 1) (Num 2)) }$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
לכן צריך לכתוב פונקצית עזר 
\begin_inset Formula $\text{arith-op}$
\end_inset

 שתדע לבצע את הפעולות הארימתטיות בין המספרים ולהחזיר 
\begin_inset Formula $FLANG$
\end_inset

 מתאים
\end_layout

\begin_layout LyX-Code

\lang english
{call {With {y 2} 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
 {fun {x} {+ x y}}}
\end_layout

\begin_layout LyX-Code

\lang english
3}
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
כחלק מהשינוי ל
\begin_inset Formula $FLANG$
\end_inset

 ב 
\begin_inset Formula $eval$
\end_inset

, נרצה ב
\begin_inset Formula $run$
\end_inset

 להחזיר את המספרי ולכן נוסיף בדיקה שתעזור לנו.
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
הקוד:
\end_layout

\begin_layout LyX-Code

\lang english
(: arith-op : (Number Number -> Number) FLANG FLANG -> FLANG) 
\end_layout

\begin_layout LyX-Code

\lang english
;; gets a Racket numeric binary operator, and uses it within a FLANG 
\end_layout

\begin_layout LyX-Code

\lang english
;; `Num' wrapper (note H.O type) 
\end_layout

\begin_layout LyX-Code

\lang english
(define (arith-op op expr1 expr2)   
\end_layout

\begin_layout LyX-Code

\lang english
(: Num->number : FLANG -> Number)   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (Num->number e)     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(cases e       
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(Num n) n]       
\end_layout

\begin_layout LyX-Code

\lang english
[else (error 'arith-op "expects a number, got: ~s" e)]))   
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\lang english
(Num (op (Num->number expr1) (Num->number expr2))))
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
   
\end_layout

\begin_layout LyX-Code

\lang english
(: eval : FLANG -> FLANG)                      ; <- note return type 
\end_layout

\begin_layout LyX-Code

\lang english
;; evaluates FLANG expressions by reducing them to *expressions* 
\end_layout

\begin_layout LyX-Code

\lang english
(define (eval expr)   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(cases expr     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(Num n) expr]                             ; <- change here
\end_layout

\begin_layout LyX-Code

\lang english
[(Add l r) (arith-op + (eval l) (eval r))] ; <- change here     
\end_layout

\begin_layout LyX-Code

\lang english
[(Sub l r) (arith-op - (eval l) (eval r))] ; <- change here     
\end_layout

\begin_layout LyX-Code

\lang english
[(Mul l r) (arith-op * (eval l) (eval r))] ; <- change here     
\end_layout

\begin_layout LyX-Code

\lang english
[(Div l r) (arith-op / (eval l) (eval r))] ; <- change here     
\end_layout

\begin_layout LyX-Code

\lang english
[(With bound-id named-expr bound-body)      
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(eval (subst bound-body                   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
bound-id                   
\end_layout

\begin_layout LyX-Code

\lang english
(eval named-expr)))]         ; <- no `(Num ...)'     
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\lang english
[(Id name) (error 'eval "free identifier: ~s" name)]     
\end_layout

\begin_layout LyX-Code

\lang english
[(Fun bound-id bound-body) expr]           ; <- similar to `Num'
\end_layout

\begin_layout LyX-Code

\lang english
[(Call fun-e arg-e) ; <- nested pattern      
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(let ([funv (eval fun-e)])        
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(cases funv
\end_layout

\begin_layout LyX-Code

\lang english
  [(Fun name body)
\end_layout

\begin_layout LyX-Code

\lang english
    (eval (subst  body name (eval arg-e)))]
\end_layout

\begin_layout LyX-Code

\lang english
  [ else (error 'eval "expected a function ,got ~s" funv)]))]))       
\end_layout

\end_deeper
\end_deeper
\end_deeper
\end_deeper
\begin_layout LyX-Code

\lang english
(: run : String -> Number)   
\end_layout

\begin_layout LyX-Code

\lang english
;; evaluate a FLANG program contained in a string   
\end_layout

\begin_layout LyX-Code

\lang english
(define (run str)     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(let ([result (eval (parse str))])       
\end_layout

\begin_layout LyX-Code

\lang english
(cases result         
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(Num n) n]         
\end_layout

\begin_layout LyX-Code

\lang english
[else (error 'run "evaluation returned a non-number: ~s" result)]))) 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\align left

\series bold
שיעור 
\numeric on
9
\numeric off
 
\end_layout

\begin_layout Standard
תזכורת:
\end_layout

\begin_layout Itemize
כתבנו את האובייקט 
\begin_inset Formula $FLANG$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $Subst$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $Eval$
\end_inset

 - 
\end_layout

\begin_layout Itemize
כתבנו גם את 
\begin_inset Formula $Call$
\end_inset

 ואת 
\begin_inset Formula $With$
\end_inset

 
\end_layout

\begin_layout Subsection
מודל ה 
\lang english
SubstCache
\family roman
\series bold
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\end_layout

\begin_layout Standard
נטען שהביטווים הבאים זהים:
\end_layout

\begin_layout LyX-Code

\lang english
(Call (Fun name body)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
E)
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(With name
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
E
\end_layout

\begin_layout LyX-Code

\lang english
body)
\end_layout

\end_deeper
\begin_layout Standard
דוגמאות לדמיון:
\end_layout

\begin_layout LyX-Code

\lang english
{Call {fun {x} {* x 7}}
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
5}
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
{With {x 5} {* x 7}}
\end_layout

\begin_layout Standard
אם כן למה המצאנו את שני המגנונים 
\begin_inset Formula $Call,With$
\end_inset

 ? או מה היחס בין 
\begin_inset Formula $Call$
\end_inset

 ל 
\begin_inset Formula $With$
\end_inset

 ?
\end_layout

\begin_layout Itemize
מצד אחד הביטוי 
\begin_inset Formula $with$
\end_inset

 הרבה יותר קריא.
\end_layout

\begin_deeper
\begin_layout Itemize
למעשה 
\begin_inset Formula $With$
\end_inset

 הוא 
\begin_inset Formula $\text{syntactic sugar}$
\end_inset

 של 
\begin_inset Formula $Call$
\end_inset

 , והוא מקרה פרטי שלו )ב
\begin_inset Formula $Racket$
\end_inset

 ה 
\begin_inset Formula $let$
\end_inset

 הוא באמת 
\begin_inset Formula $\text{syntactic sugar}$
\end_inset

 לקריאה לפונקציות(
\end_layout

\end_deeper
\begin_layout Itemize
מצד שני, היחוד של 
\begin_inset Formula $Call$
\end_inset

 הוא לפונקציות שאנחנו מגדירים ,ולא משתמשים באותו רגע.
 למשל:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {sqr {fun {x} { * x x}}}
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{+ {call sqr 5} {call sqr 6}}}
\end_layout

\end_deeper
\begin_layout Itemize
היכולת להגדיר את 
\begin_inset Formula $sqr$
\end_inset

 , ואז לקרוא לה פעמיים היא בזכות הגדרת ה 
\begin_inset Formula $call$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
מה למדנו כאן?
\end_layout

\begin_layout Itemize
שבביטוי 
\begin_inset Formula $\text{eval(\{call E1 E2 \})}$
\end_inset

, 
\begin_inset Formula $E1$
\end_inset

 הוא לא בהכרח פונקציה ברגע הקריאה, ויכול להיות שרק לאחר ההערכה שלו 
\begin_inset Formula $\left(eval\right)$
\end_inset

 באמת נקבל צורה של 
\begin_inset Formula $\text{Call..Fun.. }$
\end_inset

 פורמלית:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
if eval (E1)={fun {x} Ef}
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
then eval (Ef[eval/x])
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
else    error!
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\align center
דוגמה הרצה של 
\begin_inset Formula $with,call$
\end_inset

 
\end_layout

\begin_layout LyX-Code

\lang english
  (test (run "{with {identity {fun {x} x}}
\end_layout

\begin_layout LyX-Code

\lang english
                {with {foo {fun {x} {+ x 1}}}
\end_layout

\begin_layout LyX-Code

\lang english
                  {call {call identity foo} 123}}}")
\end_layout

\begin_layout LyX-Code

\lang english
        => 124) 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
הראנו ש 
\begin_inset Formula $With$
\end_inset

 הוא בעצם כמו 
\begin_inset Formula $Call$
\end_inset

 
\begin_inset Formula $\Leftarrow$
\end_inset

 ניתן להתיחחס ל
\begin_inset Formula $with$
\end_inset

 כמו לפונקציה.
\end_layout

\begin_layout Standard
החסרון שב
\begin_inset Formula $with/call$
\end_inset

 כל קריאה לפונקציה גורמת לנו לחזור על הקוד שוב ושוב בשביל לבצע את ההחלפות,
 וזה יוצר חוסר יעילות מאוד גדול.
 לכן נרצה ל
\begin_inset Quotes erd
\end_inset

שמור
\begin_inset Quotes erd
\end_inset

 במעבר ראשון את כל הפונקציות , בשביל שבמעבר שני כבר נוכל לבצע את כל ההחלפות
 ולא לסרוק את הקוד שוב ושוב.
 לשם כך, נממש מעין מחסנית של פונקציות.
 נקרא לו: 
\end_layout

\begin_layout LyX-Code

\lang english
;; a type for substitution caches: 
\end_layout

\begin_layout LyX-Code

\lang english
(define-type SubstCache = (Listof (List Symbol FLANG)))
\begin_inset Newline newline
\end_inset

;;
\end_layout

\begin_layout LyX-Code

\lang english
(: empty-subst : SubstCache) 
\end_layout

\begin_layout LyX-Code

\lang english
(define empty-subst null)
\end_layout

\begin_layout LyX-Code

\lang english
;;
\end_layout

\begin_layout LyX-Code

\lang english
(: extend : Symbol FLANG SubstCache -> SubstCache) 
\end_layout

\begin_layout LyX-Code

\lang english
(define (extend id expr sc)
\end_layout

\begin_layout LyX-Code

\lang english
  (cons (list id expr) sc))
\begin_inset Newline newline
\end_inset

;;
\end_layout

\begin_layout LyX-Code

\lang english
(: lookup : Symbol SubstCache -> FLANG)
\end_layout

\begin_layout LyX-Code

\lang english
(define (lookup name sc)
\end_layout

\begin_layout LyX-Code

\lang english
  (cond [(null? sc)(error 'lookup "no binding for ~s" name)]
\end_layout

\begin_layout LyX-Code

\lang english
        [(eq? name (first (first sc))) (second (first sc))]
\end_layout

\begin_layout LyX-Code

\lang english
        [else (lookup name (rest sc))]))
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
שיפור: נשתמש בפונקציה של 
\begin_inset Formula $racket$
\end_inset

 שיודעת לעבוד עם מבנה של רשימה של רשימות בשם 
\begin_inset Formula $assq$
\end_inset

, לדגומה:
\end_layout

\begin_layout LyX-Code

\lang english
> (assq 3 (list (list 1 2) (list 3 4) (list 5 6)))
\end_layout

\begin_layout LyX-Code

\lang english
'(3 4) 
\end_layout

\begin_layout LyX-Code

\lang english
> (assq 7 (list (list 1 2) (list 3 4) (list 5 6))) 
\end_layout

\begin_layout LyX-Code

\lang english
#f  
\end_layout

\begin_layout Standard
ולכן נוכל להשתמש בה )הכי קרוב למילון ב 
\begin_inset Formula $Racket$
\end_inset

 (
\end_layout

\begin_layout LyX-Code

\lang english
(: lookup : Symbol SubstCache -> FLANG)   
\end_layout

\begin_layout LyX-Code

\lang english
(define (lookup name sc)     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(let ([cell (assq name sc)])       
\end_layout

\begin_layout LyX-Code

\lang english
(if cell         
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(second cell)         
\end_layout

\begin_layout LyX-Code

\lang english
(error 'lookup "no binding for ~s" name))))
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
ב
\begin_inset Formula $parser$
\end_inset

 אין מה לשנות, ב
\begin_inset Formula $eval$
\end_inset

 צריך לשנות:
\end_layout

\begin_layout Itemize
\begin_inset Formula $eval$
\end_inset

 צריכה עכשיו לקבל את המחסנית, ולעבור בין כל הקריאות הרקורסיביות
\end_layout

\begin_layout Itemize
\begin_inset Formula $eval(id)$
\end_inset

 - ידרוש ממנו ללכת לחפש במחסנית 
\begin_inset Formula $\left(\text{look-up}\right)$
\end_inset

 אם זו פנוקציה מוכרת, 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $lookup$
\end_inset

 צריכה לדעת להחזיר רק את המתשנה שאני מחפש.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $eval(with)$
\end_inset

 - יגרום לנו להוסיף לתחילת המחסנית משתנה עם השם והערך
\end_layout

\begin_deeper
\begin_layout Itemize
נשים לב שאם יש לנו 
\begin_inset Formula $with$
\end_inset

 בתוך 
\begin_inset Formula $with$
\end_inset

 עם אותו שם למשתנה )למשל 
\begin_inset Formula $x$
\end_inset

 ( אז המשתנה החיצוני ידרס, וזה לא פוגע במשמעות כי ההחלפות מתבצעות בסדר של
 שכבות הריקורסיה
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $eval(call)$
\end_inset

 דומה ל
\begin_inset Formula $with$
\end_inset

 ועל פי הלוגיקה שהסברנו בתחילת השיעור.
 
\end_layout

\begin_layout Itemize

\series bold
נשים לב: 
\series default
ניתן למחוק כעת את 
\begin_inset Formula $Subst$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\bar under
\lang english
Lookup rules:
\end_layout

\begin_layout Standard

\lang english
lookup(x,empty-subst) = error! 
\end_layout

\begin_layout Standard

\lang english
lookup(x,extend(x,E,sc)) = E 
\end_layout

\begin_layout Standard

\lang english
lookup(x,extend(y,E,sc)) = lookup(x,sc) if `x' is not `y'
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\bar under
\lang english
Evaluation rules:
\end_layout

\begin_layout Standard

\lang english
eval(N,sc) = N 
\end_layout

\begin_layout Standard

\lang english
eval({+ E1 E2},sc) = eval(E1,sc) + eval(E2,sc) 
\end_layout

\begin_layout Standard

\lang english
eval({- E1 E2},sc) = eval(E1,sc) - eval(E2,sc) 
\end_layout

\begin_layout Standard

\lang english
eval({* E1 E2},sc) = eval(E1,sc) * eval(E2,sc) 
\end_layout

\begin_layout Standard

\lang english
eval({/ E1 E2},sc) = eval(E1,sc) / eval(E2,sc) 
\end_layout

\begin_layout Standard

\lang english
eval(x,sc) = lookup(x,sc) 
\end_layout

\begin_layout Standard

\lang english
eval({with {x E1} E2},sc) = eval(E2,extend(x,eval(E1,sc),sc)) 
\end_layout

\begin_layout Standard

\lang english
eval({fun {x} E},sc) = {fun {x} E} 
\end_layout

\begin_layout Standard

\lang english
eval({call E1 E2},sc) 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\lang english
= eval(Ef,extend(x,eval(E2,sc),sc)) 
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000

\lang english
if eval(E1,sc) = {fun {x} Ef} 
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000

\lang english
= error! otherwise 
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
השינויים בקוד עצמו ל
\begin_inset Formula $eval$
\end_inset

 :
\end_layout

\begin_layout LyX-Code

\lang english
: eval : FLANG SubstCache -> FLANG)   
\end_layout

\begin_layout LyX-Code

\lang english
;; evaluates FLANG expressions by reducing them to expressions   
\end_layout

\begin_layout LyX-Code

\lang english
(define (eval expr sc)     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(cases expr       
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(Num n) expr]       
\end_layout

\begin_layout LyX-Code

\lang english
[(Add l r) (arith-op + (eval l sc) (eval r sc))]       
\end_layout

\begin_layout LyX-Code

\lang english
[(Sub l r) (arith-op - (eval l sc) (eval r sc))]       
\end_layout

\begin_layout LyX-Code

\lang english
[(Mul l r) (arith-op * (eval l sc) (eval r sc))]       
\end_layout

\begin_layout LyX-Code

\lang english
[(Div l r) (arith-op / (eval l sc) (eval r sc))]       
\end_layout

\begin_layout LyX-Code

\lang english
[(With bound-id named-expr bound-body)        
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(eval bound-body              
\end_layout

\begin_layout LyX-Code

\lang english
(extend bound-id (eval named-expr sc) sc))]       
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
[(Id name) (lookup name sc)]       
\end_layout

\begin_layout LyX-Code

\lang english
[(Fun bound-id bound-body) expr]       
\end_layout

\begin_layout LyX-Code

\lang english
[(Call fun-expr arg-expr)        
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(let ([fval (eval fun-expr sc)])          
\end_layout

\begin_layout LyX-Code

\lang english
(cases fval            
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
[(Fun bound-id bound-body)             
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(eval bound-body                   
\end_layout

\begin_layout LyX-Code

\lang english
(extend bound-id (eval arg-expr sc) sc))]            
\end_layout

\begin_layout LyX-Code

\lang english
[else (error 'eval "'call' expects a function, got: ~s" fval)]))])) 
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
והשינויים ב
\begin_inset Formula $run$
\end_inset

 :
\end_layout

\begin_layout Itemize
צריך להוסיף את המחסנית 
\begin_inset Formula $(sc)$
\end_inset

 כרשימה ריקה ולשלוח אותה ל 
\begin_inset Formula $eval$
\end_inset

 
\end_layout

\begin_layout LyX-Code

\lang english
(: run : String -> Number)   
\end_layout

\begin_layout LyX-Code

\lang english
;; evaluate a FLANG program contained in a string   
\end_layout

\begin_layout LyX-Code

\lang english
(define (run str)
\end_layout

\begin_layout LyX-Code

\lang english
    (let ([result (eval (parse str) empty-subst)])
\end_layout

\begin_layout LyX-Code

\lang english
      (cases result         
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(Num n) n]         
\end_layout

\begin_layout LyX-Code

\lang english
[else (error 'run "evaluation returned a non-number: ~s"   result)]))) 
\end_layout

\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $test$
\end_inset

 :
\end_layout

\begin_layout LyX-Code

\lang english
(test (run "{with {x 3}                 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {f {fun {y} {+ x y}}}                   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {x 5}                     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call f 4}}}}") 
\end_layout

\begin_layout LyX-Code

\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Itemize
החלפה ראשונה:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(test (run "{with {x 3}                 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {f {fun {y} {+ 
\bar under
3
\bar default
 y}}}                   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {x 5}                     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call f 4}}}}") 
\end_layout

\end_deeper
\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize
החלפה שניה:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(test (run "{with {x 3}                 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {f {fun {y} {+ x y}}}                   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {x 5}                     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call 
\bar under
{fun {y} {+ 3 y}}
\bar default
 4}}}}") 
\end_layout

\end_deeper
\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize
החלפה שלישית:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(test (run "{with {x 3}                 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {f {fun {y} {+ x y}}}                   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {x 5}                     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call {fun {y} {+ 3 
\bar under
4
\bar default
}} 4}}}}") 
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Itemize
לכאורה נקבל 
\begin_inset Formula $y=3+4=7$
\end_inset

, אבל ב
\begin_inset Formula $racket$
\end_inset

 אנחנו מקבלים
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
9
\family roman
\series medium
\shape up
\size normal
\emph off
\numeric off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
, האם זה נכון? 
\end_layout

\begin_deeper
\begin_layout Standard
תלוי במודל, ישנם שני מודלים דינאמי וסטטי ונרחיב עליהם בשיעור הבא.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\align left

\series bold
שיעור 
\numeric on
10
\end_layout

\begin_layout Subsubsection
המודל הדינמי 
\begin_inset Formula $VS$
\end_inset

 המודל הסטטי
\end_layout

\begin_layout Standard
בשיעור שעבר הגדרנו מעין מבנה נתונים 
\begin_inset Formula $\text{SubstCache}$
\end_inset

, שמשפר לנו את העבודה עם פונקציות.
\end_layout

\begin_layout Standard
והזכרנו את הטסט הבא, כטסט בעייתי:
\end_layout

\begin_layout LyX-Code

\lang english
(test (run "{with {y 4}                 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {foo {fun {x} {* x y}}}                   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {y 6}                     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call foo 7}}}}") 
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
נריץ את הטסט הזה, על פי מודל ההחלפות:
\end_layout

\begin_layout Enumerate
החלפה ראשונה - 
\begin_inset Formula $\text{\{with \{y 4\}..\}}$
\end_inset

 - דורש את חישוב ה
\begin_inset Formula $body$
\end_inset

 לאחר החלפת כל המשתני 
\begin_inset Formula $y$
\end_inset

 החופשיים ל 
\begin_inset Formula $4$
\end_inset

 , )ה
\begin_inset Formula $y$
\end_inset

 השני אינו חופשי( לכן:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
test (run "{with {y 4}                 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {foo {fun {x} {* x 
\bar under
4
\bar default
}}}                   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {y 6}                     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call foo 7}}}}")
\end_layout

\end_deeper
\end_deeper
\end_deeper
\end_deeper
\begin_layout Enumerate
החלפת 
\begin_inset Formula $with$
\end_inset

 שניה ל
\begin_inset Formula $foo$
\end_inset

 :
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
test (run "{with {y 4}                 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {foo {fun {x} {* x 
\bar under
4
\bar default
}}}                   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {y 6}                     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call 
\bar under
{foo {fun {x} {* x 4}}
\bar default
 7}}}}")
\end_layout

\end_deeper
\end_deeper
\end_deeper
\end_deeper
\begin_layout Enumerate
עכשיו צריך לחשב את ה 
\begin_inset Formula $body$
\end_inset

, אבל יש לנו שוב 
\begin_inset Formula $\text{\{with \{y 6\}...\}}$
\end_inset

, ולכן צריך להחליף את כל המשתנים החופשיים - אין לנו.
 אז נתחל לחשב את ה
\begin_inset Formula $body$
\end_inset

 :
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call 
\bar under
{foo {fun {x} {* x 4}}
\bar default
 7}
\end_layout

\begin_layout Standard
\align center
התוצאה
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
28
\end_layout

\end_deeper
\begin_layout Standard
עכשיו נריץ לפי שלבי הריצה של מודל ה 
\begin_inset Formula $\text{SubstCache}$
\end_inset

:
\end_layout

\begin_layout Itemize
בשלב ראשון נתחיל עם 
\begin_inset Formula $\text{sc=[]}$
\end_inset


\end_layout

\begin_layout Itemize
בשלב שני נקבל : 
\begin_inset Formula $\text{sc=[(y 4)]}$
\end_inset


\end_layout

\begin_layout Itemize
בשלב שלישי נקבל: 
\begin_inset Formula $\text{sc=[(foo \{fun \{x \{* x y\}\}) (y 4)]}$
\end_inset


\end_layout

\begin_layout Itemize
בשלב רביעי נקבל: 
\begin_inset Formula $\text{sc=[(y 6) (foo \{fun \{x \{* x y\}\}) (y 4)]}$
\end_inset


\end_layout

\begin_layout Itemize
בשלב חמישי נקבל: 
\begin_inset Formula $\text{call foo}$
\end_inset

 ולכן נקבל את את 
\begin_inset Formula $\text{\{fun \{x \{* x y\}}$
\end_inset


\end_layout

\begin_layout Itemize
בשלב השישי נגיע לחישוב ה
\begin_inset Formula $body$
\end_inset

 של הפונקציה , כלומר לחשב את 
\begin_inset Formula $\text{\{* x y\}}$
\end_inset

 על ידי האיבר 
\begin_inset Formula $x=7$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
בשלב זה המחסנית נראית כך: 
\begin_inset Formula $\text{sc=[(x 7) (y 6) (foo \{fun \{x \{* x y\}\}) (y 4)]}$
\end_inset


\end_layout

\begin_layout Itemize
לכן 
\begin_inset Formula $lookup$
\end_inset

 ל
\begin_inset Formula $x$
\end_inset

 יחיזר
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
7
\numeric off
, ול 
\begin_inset Formula $y$
\end_inset

 יחזיר 
\begin_inset Formula $6$
\end_inset

 ,
\end_layout

\begin_deeper
\begin_layout Standard
\align center
והתוצאה תהיה 
\begin_inset Formula $\text{\{* 6 7 \}\ensuremath{\rightarrow42}}$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
 
\end_layout

\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
כפי שראינו, שתי הריצות הגיוניות ונותנות תוצאות שונות.
 האם זה באג?
\end_layout

\begin_layout Standard
נשים לב שההבדלים נובעים מהזמן בו מוחלף ה
\begin_inset Formula $y$
\end_inset

 הראשון בפונקציה 
\begin_inset Formula $y$
\end_inset

 - במודל ההחלפות ברגע שהתייחסו ל
\begin_inset Formula $y$
\end_inset

 כמשתנה חופשי החלפנו אותו ב
\begin_inset Formula $4$
\end_inset

 , ולכן הפונקציה 
\begin_inset Formula $foo$
\end_inset

 עבדה עם 
\begin_inset Formula $y=4$
\end_inset

.
 לעומת זאת במודל ה 
\begin_inset Formula $sc$
\end_inset

 הכנסנו את הפונקציה 
\begin_inset Formula $foo$
\end_inset

 כמו שהיא למחסנית ובשלב זה 
\begin_inset Formula $y$
\end_inset

 עדיין לא נקבע.
 בגישה זו 
\begin_inset Formula $foo$
\end_inset

 מבחינתנו הוא אובייקט בטוח, והערכים שלו נקבעים רק כאשר מתבצע 
\begin_inset Formula $call$
\end_inset


\end_layout

\begin_layout Standard
ההבדל הזה למעשה מגדיר שני מודלים, דינמי וסטטי ואלו ההגדרות:
\end_layout

\begin_layout Itemize

\bar under
\lang english
Static Scope
\bar default
 (also called Lexical Scope):
\end_layout

\begin_deeper
\begin_layout Itemize

\lang english
In a language with static scope, each identifier gets its value from the
\bar under
 scope in which it was defined
\bar default
 (not the one in which it is used).
\end_layout

\begin_layout Itemize
הערכים מוגדרים בשלב ההגדרה.
\end_layout

\end_deeper
\begin_layout Itemize

\bar under
\lang english
Dynamic Scope: 
\end_layout

\begin_deeper
\begin_layout Itemize

\lang english
In a language with dynamic scope, each identifier gets its value from the
 
\bar under
scope of its use
\bar default
 (not its definition).
 
\end_layout

\begin_layout Itemize
הערכים מוגדרים בשלב השימוש.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
הרצה במודל הסטטי:
\end_layout

\begin_layout LyX-Code

\lang english
#lang pl untyped
\end_layout

\begin_layout LyX-Code

\lang english
#lang pl dynamic
\end_layout

\begin_layout LyX-Code

\lang english
(define x 123)
\end_layout

\begin_layout LyX-Code

\lang english
(define (getx) x)
\end_layout

\begin_layout LyX-Code

\lang english
(define (bar1 x) (getx)) 
\end_layout

\begin_layout LyX-Code

\lang english
(define (bar2 y) (getx))
\end_layout

\begin_layout LyX-Code

\lang english
;;
\end_layout

\begin_layout LyX-Code

\lang english
(test (getx) => 123) ;; 
\end_layout

\begin_layout LyX-Code

\lang english
(test (let ([x 456]) (getx)) => 123) ;; (1)
\end_layout

\begin_layout LyX-Code

\lang english
(test (getx) => 123) 
\end_layout

\begin_layout LyX-Code

\lang english
(test (bar1 999) => 123) 
\end_layout

\begin_layout LyX-Code

\lang english
(test (bar2 999) => 123)
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\align center

\numeric on
1
\numeric off
.
 הפונקציה 
\begin_inset Formula $getX$
\end_inset

 הוגדרה עם הערך 
\begin_inset Formula $123$
\end_inset

 , ולכן 
\series bold
תמיד
\series default
 תחזיר
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
123
\end_layout

\begin_layout Standard
אותה הרצה עם המודל הדינמי
\end_layout

\begin_layout LyX-Code

\lang english
#lang pl dynamic
\end_layout

\begin_layout LyX-Code

\lang english
;;
\end_layout

\begin_layout LyX-Code

\lang english
(define x 123)
\end_layout

\begin_layout LyX-Code

\lang english
(define (getx) x)
\end_layout

\begin_layout LyX-Code

\lang english
(define (bar1 x) (getx)) 
\end_layout

\begin_layout LyX-Code

\lang english
(define (bar2 y) (getx))
\end_layout

\begin_layout LyX-Code

\lang english
;;
\end_layout

\begin_layout LyX-Code

\lang english
(test (getx) => 123)  
\end_layout

\begin_layout LyX-Code

\lang english
(test (let ([x 456]) (getx)) => 456) ;; (1)
\end_layout

\begin_layout LyX-Code

\lang english
(test (getx) => 123) ;; (2)
\end_layout

\begin_layout LyX-Code

\lang english
(test (bar1 999) => 999) ;; (3)
\end_layout

\begin_layout LyX-Code

\lang english
(test (bar2 999) => 123) ;; (4)
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\align center

\numeric on
1
\numeric off
.
 במודל הדינמי ה 
\begin_inset Formula $getx$
\end_inset

 תוגדר בעזרת ה
\begin_inset Formula $x$
\end_inset

 שב
\begin_inset Formula $let$
\end_inset

 ולכן תחזיר 
\begin_inset Formula $456$
\end_inset

 .

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
2
\numeric off
.
 יצאנו מה
\begin_inset Formula $scope$
\end_inset

 ולכן נחזיר להגדרה הוקדמת של 
\begin_inset Formula $x$
\end_inset

 .

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
3
\numeric off
.
 ב
\begin_inset Formula $scope$
\end_inset

 הזה 
\begin_inset Formula $x$
\end_inset

 מוגדר עם 
\begin_inset Formula $999$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
4
\numeric off
.
 
\begin_inset Formula $y$
\end_inset

 מוקשר ל
\numeric on
999
\family roman
\series medium
\shape up
\size normal
\emph off
\numeric off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
וחזרנו להגדרה המקורית של 
\begin_inset Formula $x=123$
\end_inset

 
\end_layout

\begin_layout Standard
המשך הדוגמה:
\end_layout

\begin_layout LyX-Code

\lang english
#lang pl dynamic
\end_layout

\begin_layout LyX-Code

\lang english
(define x 123)
\end_layout

\begin_layout LyX-Code

\lang english
(define (getx) x)
\end_layout

\begin_layout LyX-Code

\lang english
(define (bar1 x) (getx))   
\end_layout

\begin_layout LyX-Code

\lang english
(define (bar2 y) (getx))
\end_layout

\begin_layout LyX-Code

\lang english
;;
\end_layout

\begin_layout LyX-Code

\lang english
(define (foo x) ;; (1)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (helper) (+ x 1)) helper)   
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(test ((foo 0)) => 1)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\lang english
;; and *much* worse: (2)  
\end_layout

\begin_layout LyX-Code

\lang english
(define (add x y) (+ x y))   
\end_layout

\begin_layout LyX-Code

\lang english
(test (let ([+ *])
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(add 6 7)) => ?) 
\end_layout

\end_deeper
\begin_layout Standard

\bar under
במודל הסטטי:
\end_layout

\begin_layout Enumerate
ה
\begin_inset Formula $helper$
\end_inset

 בהגדרה שלה , מוגדרת על ידי 
\begin_inset Formula $0,1$
\end_inset

 ולכן 
\begin_inset Formula $foo$
\end_inset

 תחזיר 
\begin_inset Formula $0+1=1$
\end_inset


\end_layout

\begin_layout Enumerate
הגדרנו את 
\begin_inset Formula $+$
\end_inset

 להיות 
\begin_inset Formula $*$
\end_inset

 , במודל הסטטי ה
\begin_inset Formula $+$
\end_inset

 מוגדר כבר בזמן הגדרת הפונקציה ולכן נקבל 
\begin_inset Formula $6+7=13$
\end_inset


\end_layout

\begin_layout Standard

\bar under
בגרסה הדינמית:
\end_layout

\begin_layout Enumerate
ה
\begin_inset Formula $helper$
\end_inset

 נשמרת ה 
\begin_inset Formula $\text{\{+ x 1\} }$
\end_inset

 וכאשר אנחנו יוצאים מה
\begin_inset Formula $scope$
\end_inset

 ה
\begin_inset Formula $x$
\end_inset

 כבר לא מוגדר כ
\numeric on
0
\family roman
\series medium
\shape up
\size normal
\emph off
\numeric off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
, ולכן כאשר קוראים ל 
\begin_inset Formula $foo$
\end_inset

 היא נקראת עם 
\begin_inset Formula $x=123$
\end_inset

 והתוצאה היא 
\begin_inset Formula $124$
\end_inset


\end_layout

\begin_layout Enumerate
הגדרנו את 
\begin_inset Formula $+$
\end_inset

 להיות 
\begin_inset Formula $*$
\end_inset

 , במודל הדינמי זה מה שנשתמש בקריאת הפונקציה עם ה
\begin_inset Formula $+$
\end_inset

 ולכן נקבל 
\begin_inset Formula $6*7=42$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
דוגמה נוספת:
\end_layout

\begin_layout LyX-Code

\lang english
#lang pl dynamic
\end_layout

\begin_layout LyX-Code

\lang english
(define tax% 6.5)   
\end_layout

\begin_layout LyX-Code

\lang english
(define (with-tax n)     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(+ n (* n (/ tax% 100))))
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(with-tax 10) ; how much do we pay?   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(let ([tax% 17.0]) (with-tax 10)) ; how much would we pay in Israel?
\end_layout

\begin_layout LyX-Code

\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
;; make that into a function   
\end_layout

\begin_layout LyX-Code

\lang english
(define il-tax% 17.0)   
\end_layout

\begin_layout LyX-Code

\lang english
(define (us-over-il-saving n)     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(- (let ([tax% il-tax%]) (with-tax n))        
\end_layout

\begin_layout LyX-Code

\lang english
(with-tax n)))
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(us-over-il-saving 10)
\end_layout

\begin_layout LyX-Code

\lang english
;; can even control that: how much would we save if the tax in israel  
 
\end_layout

\begin_layout LyX-Code

\lang english
;; went down one percent?   
\end_layout

\begin_layout LyX-Code

\lang english
(let ([il-tax% (- il-tax% 1)]) (us-over-il-saving 10))
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
בדוגמה חישוב 
\begin_inset Formula $tax$
\end_inset

 באזורים שונים -שכ
\begin_inset Quotes erd
\end_inset

א יש לו אחוז אחר של 
\begin_inset Formula $tax$
\end_inset

 , ניתן לראות שבקלות אנחנו עוברים מ
\begin_inset Formula $tax$
\end_inset

 אמריקאי ל 
\begin_inset Formula $tax$
\end_inset

 ישראלי.
 משמעות הדבר שהמודל הדינמי נותן לנו להתממשק בקלות עם תוכנה קיימת.
 מצד שני קל בקלות לצור באגים - יש לא מעט החלטות שהמתכנת מקבל תוך כדי ריצה
 מסיבות מסוימות ודריסה של המידע שהוא קבע יכול לצור באג.
 לכן רוב השפות הן סטטיות.
 
\end_layout

\begin_layout Standard
לכן נרצה לחזור לקוד שלנו, ולשנות אותו שיהיה עם המחסנית ושבכל זאת יהיה סטטי
 - בדוגמה מתחילת השיעור נרצה שהתוצאה תהיה
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
28
\family roman
\series medium
\shape up
\size normal
\emph off
\numeric off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 , איך נעשה זאת? נצטרך לטפל בשמירה של פונקציה.
 
\end_layout

\begin_layout Subsection
\begin_inset Formula $Closure$
\end_inset

 - מודל הסביבות
\end_layout

\begin_layout Standard
נגדיר אובייקט שגם יחזיק את הפונקציה, וגם את ה 
\begin_inset Formula $sc$
\end_inset

 )נראה לו בשמו המוכר 
\begin_inset Formula $env$
\end_inset

 ( , ובכך נפתור את הבעיה, לדוגמה עבור:
\end_layout

\begin_layout LyX-Code

\lang english
{with {y 4}                 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{fun {x} {* x y}}
\end_layout

\end_deeper
\begin_layout Standard
נגדיר:
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\lang english
closure:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
param-name : 'x
\end_layout

\begin_layout LyX-Code

\lang english
body: (Mul (Id 'x) (id 'y)
\end_layout

\begin_layout LyX-Code

\lang english
env: (list ('y (Num 4)))
\end_layout

\end_deeper
\begin_layout Standard
לכן צריך לבצע שני שינויים:
\end_layout

\begin_layout Enumerate
לשנות את 
\begin_inset Formula $eval$
\end_inset

 שתחזיר את 
\begin_inset Formula $closure$
\end_inset

 
\end_layout

\begin_layout Enumerate
לשנות את 
\begin_inset Formula $eval$
\end_inset

 של 
\begin_inset Formula $call$
\end_inset

 שתדע להתשמש ב 
\begin_inset Formula $env$
\end_inset

 של ה
\begin_inset Formula $closure$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
לכן נגדיר אובייקטים חדשים:
\end_layout

\begin_layout LyX-Code

\lang english
 (define-type ENV     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[EmptyEnv]     
\end_layout

\begin_layout LyX-Code

\lang english
[Extend Symbol VAL ENV])
\end_layout

\end_deeper
\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\lang english
 (define-type VAL     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[NumV Number]     
\end_layout

\begin_layout LyX-Code

\lang english
[FunV Symbol FLANG ENV])
\end_layout

\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
בנוסף נשנה את הגדרת 
\begin_inset Formula $lookup$
\end_inset

 :
\end_layout

\begin_layout Itemize
כעת יקבל את 
\begin_inset Formula $env$
\end_inset

 ויחזיר את 
\begin_inset Formula $val$
\end_inset

 
\end_layout

\begin_layout Itemize
החיפוש יהיה בריקורסיה על 
\begin_inset Formula $ENV$
\end_inset


\end_layout

\begin_layout LyX-Code

\lang english
(: lookup : Symbol ENV -> VAL)   
\end_layout

\begin_layout LyX-Code

\lang english
(define (lookup name env)     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(cases env       
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(EmptyEnv) (error 'lookup "no binding for ~s" name)]       
\end_layout

\begin_layout LyX-Code

\lang english
[(Extend id val rest-env)        
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(if (eq? id name) val (lookup name rest-env))])) 
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $arith-op$
\end_inset

 צריך לבצע את ההתאמות ל 
\begin_inset Formula $Val$
\end_inset

 ו 
\begin_inset Formula $Env$
\end_inset

 :
\end_layout

\begin_layout LyX-Code

\lang english
(: arith-op : (Number Number -> Number) VAL VAL -> VAL)   
\end_layout

\begin_layout LyX-Code

\lang english
;; gets a Racket numeric binary operator, and uses it within a NumV   
\end_layout

\begin_layout LyX-Code

\lang english
;; wrapper   
\end_layout

\begin_layout LyX-Code

\lang english
(define (arith-op op val1 val2)     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(: NumV->number : VAL -> Number)     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (NumV->number v)       
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(cases v         
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(NumV n) n]         
\end_layout

\begin_layout LyX-Code

\lang english
[else (error 'arith-op "expects a number, got: ~s" v)]))     
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\lang english
(NumV (op (NumV->number val1) (NumV->number val2)))) 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
ב 
\begin_inset Formula $eval$
\end_inset

 נשנה את :
\end_layout

\begin_layout Itemize
שהערך שמקבלים יהיה 
\begin_inset Formula $ENV$
\end_inset

 והמוחזר יהיה 
\begin_inset Formula $Val$
\end_inset


\end_layout

\begin_layout Itemize
ב
\begin_inset Formula $with$
\end_inset

 להתאים את הקוד לקונסטרקטור ולכן 
\begin_inset Formula $Extend$
\end_inset

 
\end_layout

\begin_layout Itemize
ב
\begin_inset Formula $Fun$
\end_inset

 להחזיר גם את 
\begin_inset Formula $env$
\end_inset

 על ידי 
\begin_inset Formula $FunV$
\end_inset

 )בנאי של 
\begin_inset Formula $VAL$
\end_inset

 (
\end_layout

\begin_layout Itemize
ב
\begin_inset Formula $Call$
\end_inset

 נחזיר את 
\begin_inset Formula $FunV$
\end_inset

 עם הסביבה ה
\series bold
מתאימה
\series default
, והרחבה תהיה על הסביבה ה
\series bold
נוכחית
\series default
 - וזה השינוי לסביבה סטטית
\end_layout

\begin_layout LyX-Code

\lang english
(: eval : FLANG ENV -> VAL)   
\end_layout

\begin_layout LyX-Code

\lang english
;; evaluates FLANG expressions by reducing them to values   
\end_layout

\begin_layout LyX-Code

\lang english
(define (eval expr env)     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(cases expr       
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(Num n) (NumV n)]       
\end_layout

\begin_layout LyX-Code

\lang english
[(Add l r) (arith-op + (eval l env) (eval r env))]       
\end_layout

\begin_layout LyX-Code

\lang english
[(Sub l r) (arith-op - (eval l env) (eval r env))]       
\end_layout

\begin_layout LyX-Code

\lang english
[(Mul l r) (arith-op * (eval l env) (eval r env))]       
\end_layout

\begin_layout LyX-Code

\lang english
[(Div l r) (arith-op / (eval l env) (eval r env))]       
\end_layout

\begin_layout LyX-Code

\lang english
[(With bound-id named-expr bound-body)        
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(eval bound-body              
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(Extend bound-id (eval named-expr env) env))]       
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\lang english
[(Id name) (lookup name env)]       
\end_layout

\begin_layout LyX-Code

\lang english
[(Fun bound-id bound-body)        
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(FunV bound-id bound-body env)]       
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
[(Call fun-expr arg-expr)       
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(let ([fval (eval fun-expr env)])    
\end_layout

\begin_layout LyX-Code

\lang english
(cases fval     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(FunV bound-id bound-body f-env); We expect a closure   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(eval bound-body                   
\end_layout

\begin_layout LyX-Code

\lang english
  (Extend bound-id (eval arg-expr env) f-env))]      
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
[else (error 'eval "`call' expects a function, got: ~s"  
\end_layout

\begin_layout LyX-Code

\lang english
             fval)]))])) 
\end_layout

\end_deeper
\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
ושינוי אחרון ב 
\begin_inset Formula $run$
\end_inset

 :
\end_layout

\begin_layout Itemize
\begin_inset Formula $run$
\end_inset

 תקרא ל
\begin_inset Formula $eval$
\end_inset

 עם סביבה ריקה - 
\begin_inset Formula $EmptyEnv$
\end_inset

 
\end_layout

\begin_layout Itemize
והיא מצפה לקבל 
\begin_inset Formula $NumV$
\end_inset


\end_layout

\begin_layout LyX-Code

\lang english
(: run : String -> Number)   
\end_layout

\begin_layout LyX-Code

\lang english
;; evaluate a FLANG program contained in a string   
\end_layout

\begin_layout LyX-Code

\lang english
(define (run str)     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(let ([result (eval (parse str) (EmptyEnv))])       
\end_layout

\begin_layout LyX-Code

\lang english
(cases result         
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(NumV n) n]         
\end_layout

\begin_layout LyX-Code

\lang english
[else (error 'run "evaluation returned a non-number: ~s" result)]))) 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
לסיכום
\end_layout

\begin_layout Itemize
הצגנו שני מודלים סטטי ודינמי
\end_layout

\begin_layout Itemize
ראינו שמודל ההחלפות הוא סטטי ו 
\begin_inset Formula $sc$
\end_inset

 הוא דינמי, סיימנו במודל הסביבות ה
\begin_inset Formula $env$
\end_inset

 )סטטי(
\end_layout

\begin_layout Itemize
נריץ דוגמה על פי מודל הסביבות:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {foo {fun {x} {* x y}}}                   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {y 6}                     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call foo 7}}}
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
נקבל 
\begin_inset Formula $error$
\end_inset

 בגלל שאין 
\begin_inset Formula $binding$
\end_inset

 ל 
\begin_inset Formula $y$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize
נריץ על פי מודל ההחלפות
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {foo {fun {x} {* x y}}}                   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {y 6}                     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call foo 7}}}
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
לאחר ההחלפה:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {y 6}                     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call {foo {fun {x} {* x y}} 7}}}
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
לאחר ההחלפה: 
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call {foo {fun {x} {* x 6}} 7}}}
\end_layout

\end_deeper
\begin_layout Itemize
והתוצאה
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
42
\end_layout

\end_deeper
\begin_layout Itemize
כלומר במודל ההחלפות היה לנו באג, שלא ידע לזהות בעיה מסוימת ותקנו אותה במודל
 הסביבות.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\align left

\series bold
שיעור 
\numeric on
11
\end_layout

\begin_layout Subsubsection
הוספת 
\begin_inset Formula $Pair$
\end_inset


\end_layout

\begin_layout Standard
בשיעור האחרון - סיימנו לכתוב את ה 
\begin_inset Formula $interpeter$
\end_inset

 במודל הסביבות על ידי 
\begin_inset Formula $closure$
\end_inset

 - אובייקט סגור.
\end_layout

\begin_layout Standard
הראנו שכאן היה השינוי המשמעותי:
\end_layout

\begin_layout LyX-Code

\lang english
[(Call fun-expr arg-expr)       
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(let ([fval (eval fun-expr env)])    
\end_layout

\begin_layout LyX-Code

\lang english
(cases fval     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(FunV bound-id bound-body 
\bar under
f-env
\bar default
); We expect a closure   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(eval bound-body                   
\end_layout

\begin_layout LyX-Code

\lang english
  (Extend bound-id (eval arg-expr env) f-env))]      
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
שאלה ממבחן מהו השינוי המינמלי )בקוד( כדי להעביר את הקוד מודל הסביבות למודל
 דינמי?
\end_layout

\begin_layout Standard
תשובה: לשנות את 
\begin_inset Formula $f-env$
\end_inset

 ל
\begin_inset Formula $env$
\end_inset

 , שהמשמעות היא שה
\begin_inset Formula $env$
\end_inset

 הוא לא תלוי 
\begin_inset Formula $scope$
\end_inset

 , כי שעושים ב 
\begin_inset Formula $f-env$
\end_inset

 .
\end_layout

\begin_layout Standard
למבחן: צריך לדעת להסביר איך טסטים שונים ירוצו, במודל השונים.
\end_layout

\begin_layout Standard
איך זה עובד ב 
\begin_inset Formula $racket$
\end_inset

 עצמה:
\end_layout

\begin_layout Standard
יש לנו סביבה גלובלית, שבה יש את כל הפונקציות:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename prog-lang-picture/less11_01.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
קריאה לפונקציה 
\begin_inset Formula $add1$
\end_inset

 , יוצאת לאזור שמתסכל על שני דברים:
\end_layout

\begin_layout Itemize
מי ה 
\begin_inset Formula $param$
\end_inset

 וה
\begin_inset Formula $body$
\end_inset

 
\end_layout

\begin_layout Itemize
מי הסביבה שלו - במקרה הזה הסביבה הגלובלית
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename prog-lang-picture/less11_02.png
	scale 70

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
קריאה לפונקציה 
\begin_inset Formula $\text{(add1 5) }$
\end_inset

 - יוצר הרחבה של הסביבה הגלובלית, הולכת ושואלת את מי אני מכיר, אצלנו יכיר
 את
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
5
\family roman
\series medium
\shape up
\size normal
\emph off
\numeric off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
ואת
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
1
\family roman
\series medium
\shape up
\size normal
\emph off
\numeric off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
, אבל מי זה 
\begin_inset Formula $+$
\end_inset

 , את זה הוא לא מכיר, ולכן ילך ויקח את ה 
\begin_inset Formula $+$
\end_inset

 , וישתמש מהסביבה הגלובלית שם יתבצע תהליך זהה של פתיחת 
\begin_inset Formula $scope$
\end_inset

 - ולבסוף נקבל את התצואה של 
\begin_inset Formula $5+1$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
דוגמה נוספת:
\end_layout

\begin_layout Standard
נניח ונרצה לבנות מנגנון שיעבדו באופן דומה ל 
\begin_inset Formula $cons$
\end_inset

 שאנחנו מכירים מהרשימות, נקרא לה 
\begin_inset Formula $mycons$
\end_inset

 והיא תצור לנו זוגות:
\end_layout

\begin_layout Itemize
\begin_inset Formula $mycons$
\end_inset

 יקבל שני מספרים, ותחזיר 
\bar under
פונקציה
\bar default
 שיודעת להחזיר מספר
\end_layout

\begin_layout LyX-Code

\lang english
(: mycons : Number Number -> ((U 'first 'second) -> Number))
\end_layout

\begin_layout LyX-Code

\lang english
(define (mycons f s)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(: mypair : (U 'first 'second) -> Number)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (mypair location)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(if (eq? location 'first) f s)) mypair)
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout LyX-Code

\lang english
;;
\end_layout

\begin_layout LyX-Code

\lang english
(: myfirst : ((U 'first 'second) -> Number) -> Number)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (myfirst p)(p 'first))
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
;;
\end_layout

\begin_layout LyX-Code

\lang english
(: mysecond : ((U 'first 'second) -> Number) -> Number)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (mysecond p)(p 'second))
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
;;  -- tests --
\end_layout

\begin_layout LyX-Code

\lang english
(define p (mycons 1 2))
\end_layout

\begin_layout LyX-Code

\lang english
(test (myfirst p) => 1)
\end_layout

\begin_layout LyX-Code

\lang english
(test (mysecond p) => 2)
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
מה ראינו בעצם? שעל ידי תכנות פונקציונלי אנחנו מקבלים אובייקט שאנחנו יכולים
 לעבוד איתו.
 בדיאגרמה:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename prog-lang-picture/less11_03.png
	scale 80

\end_inset


\end_layout

\begin_layout Standard
במודל הדינמי זה עובד אחרת, ולמשל בקוד שלנו ה 
\begin_inset Formula $f$
\end_inset

 לא תהיה מוגדרת, ותחזיר שגיאה
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename prog-lang-picture/less11_05.png
	scale 70

\end_inset


\begin_inset Graphics
	filename prog-lang-picture/less11_04.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
כעת נרצה לשפר את הקוד -ולא להשתמש בסימבולים:
\end_layout

\begin_layout LyX-Code

\lang english
(: mycons : Number Number -> (
\bar under
(Number Number -> Number
\bar default
) -> Number))
\end_layout

\begin_layout LyX-Code

\lang english
(define (mycons f s)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(: mypair : 
\bar under
(Number Number -> Number)
\bar default
 -> Number)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (mypair 
\bar under
loc-sel
\bar default
)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(loc-sel f s)
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout LyX-Code

\lang english
;;
\end_layout

\begin_layout LyX-Code

\lang english
(: myfirst : (
\bar under
(Number Number -> Number) -> Number)
\bar default
 -> Number) -> Number)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (myfirst p)
\end_layout

\begin_layout LyX-Code

\lang english
(: f-sel : (Number Number -> Number)
\end_layout

\begin_layout LyX-Code

\lang english
(define (f-sel a b) a)
\end_layout

\begin_layout LyX-Code

\lang english
(p f-sel))
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
;;
\end_layout

\begin_layout LyX-Code

\lang english
(: mysecond  : (
\bar under
(Number Number -> Number) -> Number)
\bar default
 -> Number) -> Number)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(define (mysecond  p)
\end_layout

\begin_layout LyX-Code

\lang english
(: s-sel : (Number Number -> Number)
\end_layout

\begin_layout LyX-Code

\lang english
(define (s-sel a b) b)
\end_layout

\begin_layout LyX-Code

\lang english
(p s-sel))
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
;;  -- tests --
\end_layout

\begin_layout LyX-Code

\lang english
(define p (mycons 1 2))
\end_layout

\begin_layout LyX-Code

\lang english
(test (myfirst p) => 1)
\end_layout

\begin_layout LyX-Code

\lang english
(test (mysecond p) => 2)
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
ניתן גם לממש את הכל בעזרת הקוד שבנינו במהלך השיעורים על ידי החלפת ה 
\begin_inset Formula $Number$
\end_inset

 ב 
\begin_inset Formula $Val$
\end_inset

, ולהכניס זאת לקוד שלנו:
\end_layout

\begin_layout LyX-Code

\lang english
(: mycons : VAL VAL -> ((VAL VAL -> VAL) -> VAL)) 
\end_layout

\begin_layout LyX-Code

\lang english
(define (mycons f s)   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(: mypair : (VAL VAL -> VAL) -> VAL)   
\end_layout

\begin_layout LyX-Code

\lang english
(define (mypair loc-sel)     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(loc-sel f s))   
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
mypair)
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(: myfirst : ((VAL VAL -> VAL) -> VAL) -> VAL) 
\end_layout

\begin_layout LyX-Code

\lang english
(define (myfirst p)   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(: f-sel : VAL VAL -> VAL)   
\end_layout

\begin_layout LyX-Code

\lang english
(define (f-sel a b) a)   
\end_layout

\begin_layout LyX-Code

\lang english
(p f-sel)) 
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(: mysecond : ((VAL VAL -> VAL) -> VAL) -> VAL) 
\end_layout

\begin_layout LyX-Code

\lang english
(define (mysecond p)   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(: s-sel : VAL VAL -> VAL)   
\end_layout

\begin_layout LyX-Code

\lang english
(define (s-sel a b) b)   
\end_layout

\begin_layout LyX-Code

\lang english
(p s-sel))
\end_layout

\end_deeper
\begin_layout Standard
אז נעדכן את 
\begin_inset Formula $Val$
\end_inset

 :
\end_layout

\begin_layout LyX-Code

\lang english
(define-type VAL   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[NumV Number]   
\end_layout

\begin_layout LyX-Code

\lang english
[FunV Symbol FLANG ENV]   
\end_layout

\begin_layout LyX-Code

\lang english
[PairV ((VAL VAL -> VAL) -> VAL)]) 
\end_layout

\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
נעדכן את 
\begin_inset Formula $FLANG$
\end_inset

 
\end_layout

\begin_layout LyX-Code

\lang english
(define-type FLANG   [Num Number]   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[Add FLANG FLANG]   
\end_layout

\begin_layout LyX-Code

\lang english
[Sub FLANG FLANG]   
\end_layout

\begin_layout LyX-Code

\lang english
[Mul FLANG FLANG]   
\end_layout

\begin_layout LyX-Code

\lang english
[Div FLANG FLANG]   
\end_layout

\begin_layout LyX-Code

\lang english
[Id Symbol]   
\end_layout

\begin_layout LyX-Code

\lang english
[With Symbol FLANG FLANG]   
\end_layout

\begin_layout LyX-Code

\lang english
[Fun Symbol FLANG]   
\end_layout

\begin_layout LyX-Code

\lang english
[Call FLANG FLANG]   
\end_layout

\begin_layout LyX-Code

\lang english
[Cons FLANG FLANG]   
\end_layout

\begin_layout LyX-Code

\lang english
[First FLANG]   
\end_layout

\begin_layout LyX-Code

\lang english
[Second FLANG]
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
)   
\end_layout

\begin_layout Standard
נעדכן את 
\begin_inset Formula $parse-sexpr$
\end_inset

 :
\end_layout

\begin_layout LyX-Code

\lang english
(: parse-sexpr : Sexpr -> FLANG) 
\end_layout

\begin_layout LyX-Code

\lang english
;; to convert s-expressions into FLANGs 
\end_layout

\begin_layout LyX-Code

\lang english
(define (parse-sexpr sexpr)
\end_layout

\begin_layout LyX-Code

\lang english
  (match sexpr
\end_layout

\begin_layout LyX-Code

\lang english
    [(number: n)    (Num n)]
\end_layout

\begin_layout LyX-Code

\lang english
    [(symbol: name) (Id name)]
\end_layout

\begin_layout LyX-Code

\lang english
    [(cons 'with more)
\end_layout

\begin_layout LyX-Code

\lang english
     (match sexpr
\end_layout

\begin_layout LyX-Code

\lang english
       [(list 'with (list (symbol: name) named) body)
\end_layout

\begin_layout LyX-Code

\lang english
        (With name (parse-sexpr named) (parse-sexpr body))]
\end_layout

\begin_layout LyX-Code

\lang english
       [else (error 'parse-sexpr "bad `with' syntax in ~s" sexpr)])]
\end_layout

\begin_layout LyX-Code

\lang english
    [(cons 'fun more)
\end_layout

\begin_layout LyX-Code

\lang english
     (match sexpr
\end_layout

\begin_layout LyX-Code

\lang english
       [(list 'fun (list (symbol: name)) body)
\end_layout

\begin_layout LyX-Code

\lang english
        (Fun name (parse-sexpr body))]
\end_layout

\begin_layout LyX-Code

\lang english
       [else (error 'parse-sexpr "bad `fun' syntax in ~s" sexpr)])]
\end_layout

\begin_layout LyX-Code

\lang english
    [(list '+ lhs rhs) (Add (parse-sexpr lhs) (parse-sexpr rhs))]
\end_layout

\begin_layout LyX-Code

\lang english
    [(list '- lhs rhs) (Sub (parse-sexpr lhs) (parse-sexpr rhs))]
\end_layout

\begin_layout LyX-Code

\lang english
    [(list '* lhs rhs) (Mul (parse-sexpr lhs) (parse-sexpr rhs))]
\end_layout

\begin_layout LyX-Code

\lang english
    [(list '/ lhs rhs) (Div (parse-sexpr lhs) (parse-sexpr rhs))]
\end_layout

\begin_layout LyX-Code

\lang english
    [(list 'call fun arg) (Call (parse-sexpr fun) (parse-sexpr arg))]
\end_layout

\begin_layout LyX-Code

\lang english
    [(list 'cons f s) (Cons (parse-sexpr f) (parse-sexpr s))]
\end_layout

\begin_layout LyX-Code

\lang english
    [(list 'first p) (First (parse-sexpr p))]
\end_layout

\begin_layout LyX-Code

\lang english
    [(list 'second p) (First (parse-sexpr p))]
\end_layout

\begin_layout LyX-Code

\lang english
    [else (error 'parse-sexpr "bad syntax in ~s" sexpr)])) 
\end_layout

\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
נוסיף פונקציית 
\begin_inset Formula $PairV\rightarrow pair$
\end_inset

 :
\end_layout

\begin_layout LyX-Code

\lang english
(: PairV->pair : VAL -> ((VAL VAL -> VAL) -> VAL)) 
\end_layout

\begin_layout LyX-Code

\lang english
(define (PairV->pair v)   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(cases v     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(PairV p) p]     
\end_layout

\begin_layout LyX-Code

\lang english
[else (error 'PairV->pair "expects a pair, got: ~s" v)])) 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
ונעדכן את 
\begin_inset Formula $eval$
\end_inset

 :
\end_layout

\begin_layout LyX-Code

\lang english
(: eval : FLANG ENV -> VAL)   
\end_layout

\begin_layout LyX-Code

\lang english
;; evaluates FLANG expressions by reducing them to values   
\end_layout

\begin_layout LyX-Code

\lang english
(define (eval expr env)     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(cases expr       
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(Num n) (NumV n)]       
\end_layout

\begin_layout LyX-Code

\lang english
[(Add l r) (arith-op + (eval l env) (eval r env))]       
\end_layout

\begin_layout LyX-Code

\lang english
[(Sub l r) (arith-op - (eval l env) (eval r env))]       
\end_layout

\begin_layout LyX-Code

\lang english
[(Mul l r) (arith-op * (eval l env) (eval r env))]       
\end_layout

\begin_layout LyX-Code

\lang english
[(Div l r) (arith-op / (eval l env) (eval r env))]       
\end_layout

\begin_layout LyX-Code

\lang english
[(With bound-id named-expr bound-body)        
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(eval bound-body              
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(Extend bound-id (eval named-expr env) env))]       
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\lang english
[(Id name) (lookup name env)]       
\end_layout

\begin_layout LyX-Code

\lang english
[(Fun bound-id bound-body)        
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(FunV bound-id bound-body env)]       
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
[(Call fun-expr arg-expr)       
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(let ([fval (eval fun-expr env)])    
\end_layout

\begin_layout LyX-Code

\lang english
(cases fval     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(FunV bound-id bound-body f-env); We expect a closure   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(eval bound-body                   
\end_layout

\begin_layout LyX-Code

\lang english
  (Extend bound-id (eval arg-expr env) f-env))]      
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
[else (error 'eval "`call' expects a function, got: ~s"  
\end_layout

\begin_layout LyX-Code

\lang english
             fval)]))]
\end_layout

\begin_layout LyX-Code

\lang english
[(Cons a b) (PairV (mycons (eval a env) (eval b env)))] 
\end_layout

\begin_layout LyX-Code

\lang english
[(First p) (myfirst (PairV->pair (eval p env)))]  
\end_layout

\begin_layout LyX-Code

\lang english
[(Second p) (mysecond (PairV->pair (eval p env)))]
\end_layout

\end_deeper
\end_deeper
\begin_layout LyX-Code

\lang english
)) 
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
דוגמה:
\end_layout

\begin_layout LyX-Code

\lang english
(test (run "{first {cons {call {with {x 3}
\end_layout

\begin_layout LyX-Code

\lang english
                      {fun {y} {+ x y}}}
\end_layout

\begin_layout LyX-Code

\lang english
                      4}
\end_layout

\begin_layout LyX-Code

\lang english
                     {fun {e} e}}}")       => 7)
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\align left

\series bold
שיעור 
\numeric on
12
\numeric off
 
\end_layout

\begin_layout Standard
חזרה על הסביבה הגלובלית:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename prog-lang-picture/less11_06.png
	scale 70

\end_inset


\end_layout

\begin_layout Subsubsection

\lang english
\begin_inset Formula $\text{Lazy Evaluation }$
\end_inset


\end_layout

\begin_layout Standard
שאלה: מדוע ב 
\begin_inset Formula $eval$
\end_inset

 בשורה המסומנת, אנחנו שולחים את 
\begin_inset Formula $arg-exp$
\end_inset

 ולא את 
\begin_inset Formula $arg$
\end_inset

 ?
\end_layout

\begin_layout LyX-Code

\lang english
[(Call fun-expr arg-expr)       
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(let ([fval (eval fun-expr env)])    
\end_layout

\begin_layout LyX-Code

\lang english
(cases fval     
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
[(FunV bound-id bound-body f-env); We expect a closure   
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(eval bound-body                   
\end_layout

\begin_layout LyX-Code

\lang english
  (Extend bound-id 
\bar under
(eval arg-expr env) f-env)
\bar default
)] 
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
נדגים זאת בטסט בהשוואה בין שתי טסטים
\end_layout

\begin_layout Standard
טסט ראשון:
\end_layout

\begin_layout LyX-Code

\lang english
{with { f {fun {x} {* x x}}}
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call f {+ 4 6}}}
\end_layout

\end_deeper
\begin_layout Standard

\lang english
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
טסט שני:
\end_layout

\begin_layout LyX-Code

\lang english
{with { f {fun {x} {* x x}}}
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{with {z {+ 4 6}}
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
{call f z}}}
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
התשובה היא:
\end_layout

\begin_layout Itemize
שאנחנו ככה מרויחים יעילות - כלומר על שליחת של ה 
\begin_inset Formula $arg-exp$
\end_inset

 אני בעצם שולח
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
10
\family roman
\series medium
\shape up
\size normal
\emph off
\numeric off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
, ולא 
\begin_inset Formula $\text{\{+ 4 6\} }$
\end_inset

 שמחביתנו מסמל שליחת עץ - שמבחינה חישובית יכול להיות מאוד יקר.
\end_layout

\begin_layout Itemize
במודל הסביבה - אנחנו מרויחים שהביטוי מפורש לפי הסביבה, ואחרת אנו עלולים
 לבצע חישוב שגוי.
\end_layout

\begin_layout Standard
את הרעיון שהצגנו כעת, אפשר לפתח ולשאול - מה יקרה אם נריץ את:
\end_layout

\begin_layout LyX-Code

\lang english
# pl racket
\end_layout

\begin_layout LyX-Code

\lang english
;
\end_layout

\begin_layout LyX-Code

\lang english
(if 1 2 (/7 0))
\end_layout

\begin_layout Standard
התשובה: פשוט נקבל 
\begin_inset Formula $2$
\end_inset

 כי 
\begin_inset Formula $1$
\end_inset

 הוא 
\begin_inset Formula $\#t$
\end_inset

 , ולכל לא נגיע לקוד הבעייתי שדורש חלוקה ב
\numeric on
0
\numeric off
 
\end_layout

\begin_layout Standard
אבל אם נגדיר:
\end_layout

\begin_layout LyX-Code

\lang english
#lang racket
\end_layout

\begin_layout LyX-Code

\lang english
(define (myif a b c)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(if a b c)
\end_layout

\end_deeper
\begin_layout LyX-Code

\lang english
(myif 1 2 (/7 0))
\end_layout

\begin_layout Standard
אז נקבל שגיאה, כי מריצים את כל העץ = גם את 
\begin_inset Formula $c$
\end_inset

 = חלוקה באפס, והיינו רוצים שגם אצלנו נוכל לעשות 
\begin_inset Formula $\text{Lazy Evaluation }$
\end_inset

 , כלומר שנעריך ביטויים רק כשנדרש להם.
 ב
\begin_inset Formula $pl$
\end_inset

 יש אופציה להגדרה שכזו ונוסיף בתחילת הקוד את:
\end_layout

\begin_layout LyX-Code

\lang english
#lang pl lazy
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
הדגמה נוספת:
\end_layout

\begin_layout LyX-Code

\lang english
(define onces (cones 1 ones))
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
ב
\begin_inset Formula $reackt$
\end_inset

 סתם, זה יתן שגיאה כי אנחנו מגדירים אובייקט על האובייקט עצמו, אבל ב 
\begin_inset Formula $lazy$
\end_inset

 זה יתן את:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename prog-lang-picture/less12_01.png
	scale 80

\end_inset


\end_layout

\begin_layout Standard
\align center
למעשה הגדרנו אובייקט אינסופי.
\end_layout

\begin_layout Standard
הדגמה נוספת:
\end_layout

\begin_layout LyX-Code

\lang english
(define (foo x) (+ x y)
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(let ([let y 6])
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
(foo 3))
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsection*
סיכום
\end_layout

\begin_layout Standard
ב
\begin_inset Formula $racket$
\end_inset

 עצמה נקבל שגיאה - כי 
\begin_inset Formula $y$
\end_inset

 לא מוגדר ב
\begin_inset Formula $body$
\end_inset

 של 
\begin_inset Formula $foo$
\end_inset

 
\end_layout

\begin_layout Standard
ב
\begin_inset Formula $dynamic$
\end_inset

 , לא תהיה בעיה כי היא תדע לחבר את ה
\begin_inset Formula $y$
\end_inset

ל
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
6
\numeric off
 
\end_layout

\begin_layout Standard
ב 
\begin_inset Formula $pl\ lazy$
\end_inset

 , לא יצליח לבצע, כי זה שאמרנו לו להיות 
\begin_inset Formula $lazy$
\end_inset

 לא אומר שעברנו לשיטה של ל 
\begin_inset Formula $dynamic$
\end_inset

 , כלומר עדיין צריך ש
\end_layout

\begin_layout Itemize
בהגדרת הפונקציה ה 
\begin_inset Formula $y$
\end_inset

 יהיה מגודר.
 
\end_layout

\begin_layout Itemize
כל אובייקט צריך להיות מחושב פעם אחת
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\align center
~~ חזרה על הנושאים שהיה בקורס ~~
\end_layout

\begin_layout Standard
מספר הארות:
\end_layout

\begin_layout Itemize
\begin_inset Formula $racket$
\end_inset

 - שפה דינמית
\end_layout

\begin_layout Itemize
\begin_inset Formula $pl$
\end_inset

 - שפה סטטית
\end_layout

\begin_layout Itemize
השפה שבנינו 
\begin_inset Formula $FLANG$
\end_inset

 - היא דינמית )לא מבקשת הצהרה על משתנה(
\end_layout

\begin_layout Itemize
מודל הסביבות - סטטי
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\align left

\series bold
\size larger
נספח
\end_layout

\begin_layout Section
הגדרות
\end_layout

\begin_layout Subsubsection*
כללי
\end_layout

\begin_layout Enumerate

\bar under
רקורסית זנב
\bar default
: חישוב ושליחה חוזרת עד לתנאי עצירה בדרך כלל רקורסיית זנב דורשת פונקציית
 עזר
\end_layout

\begin_layout Enumerate

\bar under
\begin_inset Formula $\text{ambiguty}$
\end_inset

 
\bar default
- קיימת מילה בשפה שניתן לגזור אותה לפי שני עצי גזירה שונים
\end_layout

\begin_layout Enumerate

\bar under
\begin_inset Formula $\text{syntactic sugar}$
\end_inset

:
\bar default
 מקרה בו יש לי בשפה פתרון לפעולה מסוימת אבל אני רוצה לפשט אותה )=
\begin_inset Quotes erd
\end_inset

להמתיק
\begin_inset Quotes erd
\end_inset

( ולכן ממציא תחביר חלופי שעושה את אותו דבר.
\end_layout

\begin_layout Subsubsection
\begin_inset Formula $with$
\end_inset

 
\end_layout

\begin_layout Standard

\series bold
הגדרה פורמלית 
\begin_inset Formula $\text{Compositionality }$
\end_inset

: 
\end_layout

\begin_layout Standard
\begin_inset Formula $eval$
\end_inset

 על קודקוד 
\begin_inset Formula $T$
\end_inset

 עם בנים 
\begin_inset Formula $T_{1},..T_{k}$
\end_inset

 יבצע :
\end_layout

\begin_layout Enumerate
\begin_inset Formula $v_{1}=eval\left(T_{1}\right),v_{2}=eval\left(T_{2}\right)....v_{k}=eval\left(T_{k}\right)$
\end_inset

 
\end_layout

\begin_layout Enumerate
יבצע פעולה מקומית על 
\begin_inset Formula $v_{1},...,v_{k}$
\end_inset

 
\end_layout

\begin_layout Subsubsection*
החלפת משתנים הגדרות
\end_layout

\begin_layout Itemize
\begin_inset Formula $\text{Binding instance}$
\end_inset

 - מופע של 
\begin_inset Formula $x$
\end_inset

 , שבו אני מקשר את 
\begin_inset Formula $x$
\end_inset

 לביטוי כלשהו ) הצהרה על שם מזהה 
\begin_inset Formula $x$
\end_inset

 (
\end_layout

\begin_layout Itemize
\begin_inset Formula $\text{Scope }$
\end_inset

 - עבור 
\begin_inset Formula $\text{Binding instance}$
\end_inset

 אותו חלק בקוד שבו כל מופע של 
\begin_inset Formula $x$
\end_inset

 מקושר למופע ההצהרתי הזה
\end_layout

\begin_layout Itemize
\begin_inset Formula $\text{Bound instance}$
\end_inset

 - כל מופע של 
\begin_inset Formula $x$
\end_inset

 שאינו 
\begin_inset Formula $\text{Binding instance }$
\end_inset

 וגם נמצא בתוך 
\begin_inset Formula $scope$
\end_inset

של 
\begin_inset Formula $\text{Binding instance }$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\text{Free instance }$
\end_inset

 - כל מופע של 
\begin_inset Formula $x$
\end_inset

 שאינו 
\begin_inset Formula $\text{Binding instance }$
\end_inset

 וגם אינו 
\begin_inset Formula $\text{Bound}$
\end_inset


\begin_inset Formula 
\[
\text{\{+ \ensuremath{\underbrace{x}_{\begin{matrix}\text{free}\\
\text{incstance}
\end{matrix}}} \ensuremath{\{\text{with \{ }\ensuremath{\underbrace{\text{x}}_{\begin{matrix}\text{binding}\\
\text{incstance}
\end{matrix}}}\underbrace{\text{5}}_{\begin{matrix}\text{value}\\
\text{bound}
\end{matrix}}\text{\}}\ensuremath{\overbrace{\text{\{ + }\underbrace{\text{x}}_{\begin{matrix}\text{bound}\\
\text{instance}
\end{matrix}}\text{ 1\}}}^{\text{scope}}}\}}\}}
\]

\end_inset


\bar under
סימונים
\end_layout

\begin_deeper
\begin_layout Standard
החלף את המופעים המתאימים של 
\begin_inset Formula $name\left(=x\right)$
\end_inset

 בערך 
\begin_inset Formula $v$
\end_inset

 בתוך 
\begin_inset Formula $body\left(=e\right)$
\end_inset


\end_layout

\begin_layout Enumerate
הסינטקס: 
\begin_inset Formula $\text{[name/v]body}$
\end_inset


\end_layout

\begin_layout Enumerate
: פורמלית: 
\begin_inset Formula $\left[x/v\right]e$
\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
פונקציות
\end_layout

\begin_layout Enumerate
פונקציית 
\begin_inset Formula $\left(\text{first order}\right)$
\end_inset

 - אובייקט שיודע לבצע חישוב, לא יכול לשמור 
\begin_inset Formula $data$
\end_inset


\end_layout

\begin_layout Enumerate
פונקציית 
\begin_inset Formula $\left(\text{high order }\right)$
\end_inset

 - אובייקט יותר מורכב שניתן להביע איתו חישובים ותהלכים ברמה גבוה וקריאה,
 בעל אפשרות של שליחה וקבלת פונקציה כמשתנה.
\end_layout

\begin_layout Enumerate
פונקצית 
\begin_inset Formula $\left(\text{First class}\right)$
\end_inset

 - שפות בהן פונקציה היא טיפוס כמו כל טיפוס אחר 
\begin_inset Formula $\Leftarrow$
\end_inset

 נותן לנו את האפשרות לפונקציה ללא שם )אנונימית(
\end_layout

\begin_deeper
\begin_layout Enumerate
מאפשר להגדיר פונקציה בזמן ריצה
\end_layout

\begin_layout Enumerate
יכולות להשמר במבנה נתונים, ועוד.
\end_layout

\end_deeper
\begin_layout Itemize

\bar under
\lang english
Static Scope
\bar default
 (also called Lexical Scope):
\end_layout

\begin_deeper
\begin_layout Itemize

\lang english
In a language with static scope, each identifier gets its value from the
\bar under
 scope in which it was defined
\bar default
 (not the one in which it is used).
\end_layout

\begin_layout Itemize
הערכים מוגדרים בשלב ההגדרה.
\end_layout

\end_deeper
\begin_layout Itemize

\bar under
\lang english
Dynamic Scope: 
\end_layout

\begin_deeper
\begin_layout Itemize

\lang english
In a language with dynamic scope, each identifier gets its value from the
 
\bar under
scope of its use
\bar default
 (not its definition).
 
\end_layout

\begin_layout Itemize
הערכים מוגדרים בשלב השימוש.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout LyX-Code

\lang english
closure:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\lang english
param-name : 'x
\end_layout

\begin_layout LyX-Code

\lang english
body: (Mul (Id 'x) (id 'y)
\end_layout

\begin_layout LyX-Code

\lang english
env: (list ('y (Num 4)))
\end_layout

\end_deeper
\begin_layout Section
הערות 
\begin_inset Formula $parse$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $With$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $name$
\end_inset

 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $val\backslash named$
\end_inset

 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $body$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $Fun$
\end_inset

 :
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $name\backslash param$
\end_inset

 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $body$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $Call$
\end_inset

 :
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $fun\ name$
\end_inset

 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $fun\ arg$
\end_inset


\end_layout

\end_deeper
\begin_layout Section
אלגוריתמים ב 
\begin_inset Formula $eval$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $r$
\end_inset

 : היא הקריאה ה 
\begin_inset Formula $r$
\end_inset


\end_layout

\begin_layout Standard
הערה חשובה: המספור 
\begin_inset Formula $r,r+1,r+2$
\end_inset

 הוא של פעולות נדרשות ביחס לבנאי מסוים, אבל בעצים מורכבים יתכנו הפרשים גדולים
 יותר במחסנית הקריאות
\end_layout

\begin_layout Subsection*
מודל ההחלפה:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(Num\ n\right)$
\end_inset

 :
\end_layout

\begin_deeper
\begin_layout Itemize
נחזיר את 
\begin_inset Formula $Res_{r}=\left(Num\ n\right)\iff\left(Num\ n\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(Id\ name\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
בשלב זה אסור לקבל 
\begin_inset Formula $Id$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset

 נחזיר שגיאה
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(OP\ l\ r\right)$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
גורם לשתי קריאות נוספות ל 
\begin_inset Formula $eval$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
נקרא ל 
\begin_inset Formula $eval\left(l\right)$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset


\begin_inset Formula $AST_{r+1}\left(l\right)$
\end_inset


\end_layout

\begin_layout Itemize
נקרא ל 
\begin_inset Formula $eval\left(r\right)$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset


\begin_inset Formula $AST_{r+2}\left(r\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Res_{r}$
\end_inset

 מחכה לתוצאה
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(Fun\ b-id\ b-body)\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
מחזיר את הפונקציה 
\begin_inset Formula $\iff$
\end_inset

 
\begin_inset Formula $RES_{r}=\left(Fun....\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(With\ b-id\ named\ b-body\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
גורם לשתי קריאות נוספות ל 
\begin_inset Formula $eval$
\end_inset


\end_layout

\begin_layout Itemize
גורם לקריאת 
\begin_inset Formula $Subst$
\end_inset

 על ה
\begin_inset Formula $b-body$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
נקרא ל 
\begin_inset Formula $eval\left(named\right)$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset


\begin_inset Formula $AST_{r+1}\left(named\right)$
\end_inset


\end_layout

\begin_layout Itemize
נקרא ל 
\begin_inset Formula $subst$
\end_inset

 עם 
\begin_inset Formula $\left\{ \begin{matrix}b-body\rightarrow expr\\
b-id\rightarrow from\\
eval\left(named\right)\rightarrow to
\end{matrix}\right\} $
\end_inset

, החלפה תתבצע ל:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $named$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $b-body$
\end_inset

 רק אם 
\begin_inset Formula $b-id\neq from$
\end_inset

 
\begin_inset Formula $\Leftrightarrow$
\end_inset

 כן להחליף + לא לדרוס 
\begin_inset Formula $Scope$
\end_inset

 עם שם משתנה דומה 
\begin_inset Formula $\Leftrightarrow$
\end_inset

 רק את ה 
\begin_inset Formula $bound$
\end_inset

 שנמצא בתוך ה 
\begin_inset Formula $scope$
\end_inset

 (
\end_layout

\end_deeper
\begin_layout Itemize
קרא ל 
\begin_inset Formula $eval\left(b-body\right)$
\end_inset

 על ה 
\begin_inset Formula $body$
\end_inset

 
\bar under
המעודכן
\bar default
 
\begin_inset Formula $\iff$
\end_inset

 
\begin_inset Formula $AST_{r+2}\left(b-body\right)$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Res$
\end_inset

 מחכה לתוצאה
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(Call\ f-expr\ arg)\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
גורם לשלוש קריאות נוספות ל 
\begin_inset Formula $eval$
\end_inset

 
\end_layout

\begin_layout Itemize
קריאה ל
\begin_inset Formula $subst$
\end_inset

 על ה 
\begin_inset Formula $b-body$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
וידוא ש 
\begin_inset Formula $f-expr$
\end_inset

 הוא פונקציה 
\begin_inset Formula $eval\left(f-expr\ env_{r}\right)$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset

 
\begin_inset Formula $AST_{r+1}\left(f-expr\ env_{r}\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
אם לא - מחזירים שגיאה
\end_layout

\begin_layout Itemize
אם כן נשתמש בפרמטים 
\begin_inset Formula $b-id,b-body$
\end_inset

, ו:
\end_layout

\end_deeper
\begin_layout Itemize
נקרא ל 
\begin_inset Formula $eval\left(arg\right)$
\end_inset

 עם 
\begin_inset Formula $env_{r}$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset

 
\begin_inset Formula $AST_{r+2}\left(arg\ env_{r}\right)$
\end_inset


\end_layout

\begin_layout Itemize
נקרא ל 
\begin_inset Formula $subst$
\end_inset

 עם 
\begin_inset Formula $\left\{ \begin{matrix}b-body\rightarrow expr\\
b-id\rightarrow from\\
eval\left(arg\right)\rightarrow to
\end{matrix}\right\} $
\end_inset

 ,החלפה תתבצע ל:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $arg$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $b-body$
\end_inset

 רק אם 
\begin_inset Formula $b-id\neq from$
\end_inset

 
\begin_inset Formula $\Leftrightarrow$
\end_inset

 כן להחליף + לא לדרוס 
\begin_inset Formula $Scope$
\end_inset

 עם שם משתנה דומה 
\begin_inset Formula $\Leftrightarrow$
\end_inset

 רק את ה 
\begin_inset Formula $bound$
\end_inset

 שנמצא בתוך ה 
\begin_inset Formula $scope$
\end_inset

 (
\end_layout

\end_deeper
\begin_layout Itemize
נקרא ל 
\begin_inset Formula $eval\left(b-body\right)$
\end_inset

 על ה 
\begin_inset Formula $body$
\end_inset

 
\bar under
המעודכן
\bar default
 
\begin_inset Formula $\iff$
\end_inset

 
\begin_inset Formula $AST_{r+3}\left(b-body\right)$
\end_inset

 
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection*
מודל ה
\begin_inset Formula $SC$
\end_inset

:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(Num\ n\right)$
\end_inset

 :
\end_layout

\begin_deeper
\begin_layout Itemize
נחזיר את 
\begin_inset Formula $Res_{r}=n\iff n$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $SC$
\end_inset

 לא משתנה
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(Id\ name\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
נחזיר את 
\begin_inset Formula $lookup\left(name\right)$
\end_inset

 עבור ה 
\begin_inset Formula $SC_{r}$
\end_inset

 המתאים )מושפע מעץ הקריאות( 
\begin_inset Formula $\iff$
\end_inset

 
\begin_inset Formula $Res_{r}=lookup\left(name\ SC_{r}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $SC$
\end_inset

 לא משתנה
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(OP\ l\ r\right)$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
גורם לשתי קריאות נוספות ל 
\begin_inset Formula $eval$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
נקרא ל 
\begin_inset Formula $eval\left(l\right)$
\end_inset

 עם 
\begin_inset Formula $SC_{r}$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset


\begin_inset Formula $AST_{r+1}\left(l\right)$
\end_inset


\end_layout

\begin_layout Itemize
נקרא ל 
\begin_inset Formula $eval\left(r\right)$
\end_inset

 עם 
\begin_inset Formula $SC_{r}$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset


\begin_inset Formula $AST_{r+2}\left(r\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Res_{r}$
\end_inset

 מחכה לתוצאה
\end_layout

\begin_layout Itemize
\begin_inset Formula $SC$
\end_inset

 לא משתנה
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(Fun\ b-id\ b-body)\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
מחזיר את הפונקציה 
\begin_inset Formula $\iff$
\end_inset

 
\begin_inset Formula $RES_{r}=\left(Fun....b-body\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $SC_{r}$
\end_inset

 לא משתנה
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(With\ b-id\ named\,b-body\right)$
\end_inset

, עם 
\begin_inset Formula $SC_{r}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
גורם לשתי קריאות נוספות ל 
\begin_inset Formula $eval$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
נקרא ל 
\begin_inset Formula $eval\left(named\ env_{r}\right)$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset


\begin_inset Formula $AST_{r+1}\left(named\right)$
\end_inset


\end_layout

\begin_layout Itemize
נרחיב את את 
\begin_inset Formula $SC_{r}$
\end_inset

 במעבר ל 
\begin_inset Formula $AST_{r+2}$
\end_inset

 עם הזוג: )
\begin_inset Formula $b-id$
\end_inset

 , התוצאה על 
\begin_inset Formula $named$
\end_inset

(
\end_layout

\begin_layout Itemize
נקרא ל 
\begin_inset Formula $eval\left(b-body\ SC_{r+2}\right)$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset

 
\begin_inset Formula $AST_{r+2}\left(b-body\right)$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Res_{r}$
\end_inset

 מחכה לתוצאה
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(Call\ f-expr\ arg)\right)$
\end_inset

 עם 
\begin_inset Formula $SC_{r}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
גורם לשלוש קריאות נוספות ל 
\begin_inset Formula $eval$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
וידוא ש 
\begin_inset Formula $f-expr$
\end_inset

 הוא פונקציה 
\begin_inset Formula $eval\left(f-expr\ sc_{r}\right)$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset

 
\begin_inset Formula $AST_{r+1}\left(f-expr\ sc_{r}\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
אם לא - מחזירים שגיאה
\end_layout

\begin_layout Itemize
אם כן נשתמש בפרמטים 
\begin_inset Formula $b-id,b-body$
\end_inset

, ו:
\end_layout

\end_deeper
\begin_layout Itemize
נקרא ל 
\begin_inset Formula $eval\left(arg\right)$
\end_inset

 עם 
\begin_inset Formula $sc_{r}$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset

 
\begin_inset Formula $AST_{r+2}\left(arg\ sc_{r}\right)$
\end_inset


\end_layout

\begin_layout Itemize
נרחיב את 
\begin_inset Formula $sc_{r}$
\end_inset

 במעבר ל 
\begin_inset Formula $ENV_{r+3}$
\end_inset

 עם הזוג: )
\begin_inset Formula $b-id$
\end_inset

 , התוצאה על 
\begin_inset Formula $arg$
\end_inset

(
\end_layout

\begin_layout Itemize
נקרא ל 
\begin_inset Formula $eval\left(b-body\ Extend\left(SC\right)\right)$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset

 
\begin_inset Formula $AST_{r+3}\left(b-body\right)$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Res$
\end_inset

 מחכה לתוצאה
\end_layout

\end_deeper
\begin_layout Subsection*
מודל הסביבות:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(Num\ n\right)$
\end_inset

 :
\end_layout

\begin_deeper
\begin_layout Itemize
נחזיר את 
\begin_inset Formula $\left(NumV\ n\right)$
\end_inset

 , כלומר 
\begin_inset Formula $Res_{r}=\left(NumV\ n\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $ENV$
\end_inset

 לא משתנה
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(Id\ name\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
נחזיר את 
\begin_inset Formula $lookup\left(name\right)$
\end_inset

 עבור ה 
\begin_inset Formula $ENV_{r}$
\end_inset

 המתאים )מושפע מעץ הקריאות( 
\begin_inset Formula $\iff$
\end_inset

 
\begin_inset Formula $Res_{r}=lookup\left(name\ env_{r}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $ENV$
\end_inset

 לא משתנה
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(OP\ l\ r\right)$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
גורם לשתי קריאות נוספות ל 
\begin_inset Formula $eval$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
נקרא ל 
\begin_inset Formula $eval\left(l\right)$
\end_inset

 עם 
\begin_inset Formula $ENV_{r}$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset


\begin_inset Formula $AST_{r+1}\left(l\right)$
\end_inset


\end_layout

\begin_layout Itemize
נקרא ל 
\begin_inset Formula $eval\left(r\right)$
\end_inset

 עם 
\begin_inset Formula $ENV_{r}$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset


\begin_inset Formula $AST_{r+2}\left(r\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Res_{r}$
\end_inset

 מחכה לתוצאה
\end_layout

\begin_layout Itemize
\begin_inset Formula $ENV$
\end_inset

 לא משתנה
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(Fun\ b-id\ b-body)\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
מחזיר את הפונקציה 
\bar under
עם ה
\begin_inset Formula $env_{r}$
\end_inset


\bar default
 
\begin_inset Formula $\iff$
\end_inset

 
\begin_inset Formula $RES_{r}=\left(FunV....env_{r}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $ENV_{r}$
\end_inset

 לא משתנה
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(With\ b-id\ named\,b-body\right)$
\end_inset

, עם 
\begin_inset Formula $env_{r}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
גורם לשתי קריאות נוספות ל 
\begin_inset Formula $eval$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
נקרא ל 
\begin_inset Formula $eval\left(named\ env_{r}\right)$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset


\begin_inset Formula $AST_{r+1}\left(named\right)$
\end_inset


\end_layout

\begin_layout Itemize
נרחיב את את 
\begin_inset Formula $ENV$
\end_inset

 במעבר ל 
\begin_inset Formula $ENV_{r+2}$
\end_inset

 עם התוצאה על 
\begin_inset Formula $named$
\end_inset


\end_layout

\begin_layout Itemize
נקרא ל 
\begin_inset Formula $eval\left(b-body\ env_{r+1}\right)$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset

 
\begin_inset Formula $AST_{r+2}\left(b-body\right)$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Res$
\end_inset

 מחכה לתוצאה
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $AST_{r}=\left(Call\ f-expr\ arg)\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
גורם לשלוש קריאות נוספות ל 
\begin_inset Formula $eval$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
וידוא ש 
\begin_inset Formula $f-expr$
\end_inset

 הוא פונקציה 
\begin_inset Formula $eval\left(f-expr\ env_{r}\right)$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset

 
\begin_inset Formula $AST_{r+1}\left(f-expr\ env_{r}\right)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
אם לא - מחזירים שגיאה
\end_layout

\begin_layout Itemize
אם כן נשתמש בפרמטים 
\begin_inset Formula $b-id,b-body.f-env$
\end_inset

, ו:
\end_layout

\end_deeper
\begin_layout Itemize
נקרא ל 
\begin_inset Formula $eval\left(arg\right)$
\end_inset

 עם 
\begin_inset Formula $env_{r}$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset

 
\begin_inset Formula $AST_{r+2}\left(arg\ env_{r}\right)$
\end_inset


\end_layout

\begin_layout Itemize

\bar under
נרחיב את 
\begin_inset Formula $f-env$
\end_inset

 
\bar default
במעבר ל 
\begin_inset Formula $ENV_{r+3}$
\end_inset

 עם התוצאה על 
\begin_inset Formula $arg$
\end_inset


\end_layout

\begin_layout Itemize
נקרא ל 
\begin_inset Formula $eval\left(b-body\ Extend\left(f-env\right)\right)$
\end_inset

 
\begin_inset Formula $\iff$
\end_inset

 
\begin_inset Formula $AST_{r+3}\left(b-body\right)$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $Res$
\end_inset

 מחכה לתוצאה
\end_layout

\end_deeper
\end_body
\end_document
